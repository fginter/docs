<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml"
	prefix:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
	prefix:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
	prefix:oliasystem="http://purl.org/olia/system.owl#"
	prefix:xsd="http://www.w3.org/2001/XMLSchema#"
>

  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>English grammatical relations</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
	
          <span class="header-text"><a href="http://universaldependencies.org/#language-en">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          
<h1 id="universal-dependencies">Universal Dependencies</h1>

<p><span about="." property="rdf:type" resource="owl:Ontology">
	<span property="owl:imports" resource=" https://www.w3.org/2012/pyRdfa/extract?uri=http://universaldependencies.org/docs/u/dep/all.html&amp;format=xml&amp;rdfagraph=output&amp;vocab_expansion=false&amp;rdfa_lite=false&amp;embedded_rdf=true&amp;space_preserve=false&amp;vocab_cache=true&amp;vocab_cache_report=false&amp;vocab_cache_refresh=false"></span></span></p>

<pre><code>&lt;span property="owl:versionInfo"&gt; These pages draw from Section 2 of *[Stanford typed dependencies manual](http://nlp.stanford.edu/software/dependencies_manual.pdf)* (de Marneffe and Manning 2008), but have been updated for UD.
&lt;/span&gt; &lt;/span&gt;
</code></pre>

<p><span about="#dep_en" property="rdfs:label" style="visibility: hidden">English grammatical relations</span>
<span about="#dep_en" property="rdfs:subClassOf" resource="_:en">
	<span about="_:en" property="rdf:type" resource="owl:Restriction">
		<span property="owl:onProperty" resource="http://purl.org/dc/terms/language"></span>
		<span property="owl:hasValue" lang="" style="visibility: hidden">en</span>
	</span>
</span></p>

<p>Note: <i>nmod</i>, <i>neg</i> and <i>punct</i> appear
in two places.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a>nsubj</a></td>
	  <td><a>csubj</a></td>
	</tr>
	<tr>
	  <td><a>nsubjpass</a></td>
	  <td><a>csubjpass</a></td>
	</tr>
	<tr>
	  <td><a>dobj</a></td>
	  <td><a>ccomp</a></td>
	  <td><a>xcomp</a></td>
	</tr>
	<tr>
	  <td><a>iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Non-core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a>advcl</a></td>
	  <td><a>advmod</a></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:npmod</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:tmod</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:poss</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Special clausal dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a>vocative</a></td>
	  <td><a>aux</a></td>
	  <td><a>mark</a></td>
	</tr>
	<tr>
	  <td><a>discourse</a></td>
	  <td><a>auxpass</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>expl</a></td>
	  <td><a>cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Noun dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nummod</a></td>
	  <td><a>acl</a></td>
	  <td><a>amod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>↳<a>acl:relcl</a></td>
	</tr>	
	<tr>
	  <td><a>appos</a></td>
	  <td><a>det</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>↳<a>det:predet</a></td>
	</tr>	
	<tr>
	  <td><a>nmod</a></td>
	   <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Compounding and unanalyzed</strong></td></tr>
	<tr>
	  <td><a>compound</a></td>
	  <td><a>mwe</a></td>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td>↳<a>compound:prt</a></td>
	</tr>
	<tr>
	  <td><a>name</a></td>
	  <td><a>foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Coordination</strong></td></tr>
	<tr>
	  <td><a>conj</a></td>
	  <td><a>cc</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>↳<a>cc:preconj</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Case-marking, prepositions, possessive</strong></td></tr>
	<tr>
	  <td><a>case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Loose joining relations</strong></td></tr>
	<tr>
	  <td><a>list</a></td>
	  <td><a>parataxis</a></td>
	  <td><a>remnant</a></td>
	</tr>
	<tr>
	  <td><a>dislocated</a></td>
	  <td></td><td><a>reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Other</strong></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<hr />

<div about="#acl_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#acl" />
	<a id="al-en-dep/acl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">acl</code>: <div property="rdfs:label">clausal modifier of noun</div></h2>
	<div property="rdfs:comment">

`acl` is used for finite and non-finite clauses that modify a
noun. Note that in English relative clauses get assigned a specific
relation [acl:relcl](), a subtype of `acl`.

~~~ sdparse
the issues as he sees them
acl(issues, sees)
~~~

~~~ sdparse
Points to establish are ...
acl(Points, establish)
~~~

~~~ sdparse
I don't have anything to say to you
acl(anything, say)
~~~

Non-relative clause finite clausal complements for nouns are limited to complement clauses with a subset of nouns like *fact* or *report*.  We analyze them as `acl` (parallel to the analysis of this class as "content clauses" in Huddleston and Pullum 2002). Such clausal complements are usually finite (though there are occasional remnant English subjunctives). 

~~~ sdparse
I admire the fact that you are honest 
acl(fact, honest) 
mark(honest, that) 
cop(honest, are) 
nsubj(honest, you) 
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/acl.md" target="#">edit acl</a>
</div>

<div about="#acl%3Arelcl_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#acl" />
	<a id="al-en-dep/acl:relcl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">acl:relcl</code>: <div property="rdfs:label">relative clause modifier</div></h2>
	<div property="rdfs:comment">

A relative clause modifier of an noun is a relative clause modifying
the noun.  The relation points from the noun that is modified to the
head of the relative clause. Relative clauses are finite.

~~~ sdparse
I saw the man you love
acl:relcl(man, love)
~~~

~~~ sdparse
I saw the book which you bought
acl:relcl(book, bought)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/acl-relcl.md" target="#">edit acl:relcl</a>
</div>

<div about="#advcl_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#advcl" />
	<a id="al-en-dep/advcl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advcl</code>: <div property="rdfs:label">adverbial clause modifier</div></h2>
	<div property="rdfs:comment">

An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.), as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an [advmod]()) and the dependent is the main predicate of the clause.

~~~ sdparse
The accident happened as the night was falling
advcl(happened, falling)
~~~

~~~ sdparse
If you know who did it , you should tell the teacher
advcl(tell, know)
~~~

~~~ sdparse
He talked to him in order to secure the account
advcl(talked, secure)
~~~

~~~ sdparse
He was upset when I talked to him
advcl(upset, talked)
~~~

~~~ sdparse
They heard about you missing classes.
advcl(heard, missing)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/advcl.md" target="#">edit advcl</a>
</div>

<div about="#advmod_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#advmod" />
	<a id="al-en-dep/advmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advmod</code>: <div property="rdfs:label">adverbial modifier</div></h2>
	<div property="rdfs:comment">

An adverbial modifier of a word is a (non-clausal) adverb or adverbial
phrase (ADVP) that serves to modify the meaning of the word.

~~~ sdparse
Genetically modified food
advmod(modified, Genetically)
~~~

~~~ sdparse
less often
advmod(often, less)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/advmod.md" target="#">edit advmod</a>
</div>

<div about="#amod_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#amod" />
	<a id="al-en-dep/amod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">amod</code>: <div property="rdfs:label">adjectival modifier</div></h2>
	<div property="rdfs:comment">

An adjectival modifier of an NP is any adjectival phrase that serves
to modify the meaning of the NP.

~~~ sdparse
Sam eats red meat
amod(meat, red)
~~~

~~~ sdparse
Sam took out  a 3 million dollar loan
amod(loan, dollar)
~~~

~~~ sdparse
Sam took out  a $ 3 million loan
amod(loan, $)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/amod.md" target="#">edit amod</a>
</div>

<div about="#appos_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#appos" />
	<a id="al-en-dep/appos" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">appos</code>: <div property="rdfs:label">appositional modifier</div></h2>
	<div property="rdfs:comment">

An appositional modifier of an NP is an NP immediately to the right of the first NP that serves to define or modify that NP. It includes parenthesized examples, as well as defining abbreviations in one of these structures. 

~~~ sdparse
Sam , my brother , arrived
appos(Sam-1, brother-4)
~~~

~~~ sdparse
Bill ( John 's cousin )
appos(Bill-1, cousin-5)
~~~

~~~ sdparse
The Australian Broadcasting Corporation ( ABC )
appos(Corporation-4, ABC-6)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/appos.md" target="#">edit appos</a>
</div>

<div about="#aux_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#aux" />
	<a id="al-en-dep/aux" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">aux</code>: <div property="rdfs:label">auxiliary</div></h2>
	<div property="rdfs:comment">

An auxiliary of a clause is a non-main verb of the clause, e.g., a
modal auxiliary, or a form of *be*, *do* or *have* in a periphrastic
tense. 

(Contrary to the older SD and arguments of Pullum (1982) and following,
infinitive *to* is not analyzed as an auxiliary. Instead, it is analyzed
as a [mark]().)

~~~ sdparse
Reagan has died
aux(died-3, has-2)
~~~

~~~ sdparse
He should leave
aux(leave-3, should-2)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/aux_.md" target="#">edit aux</a>
</div>

<div about="#auxpass_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#auxpass" />
	<a id="al-en-dep/auxpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">auxpass</code>: <div property="rdfs:label">passive auxiliary</div></h2>
	<div property="rdfs:comment">

A passive auxiliary of a clause is a non-main verb of the clause which
contains the passive information.

~~~ sdparse
Kennedy has been killed
auxpass(killed, been)
~~~

~~~ sdparse
Kennedy was killed
auxpass(killed, was)
~~~

~~~ sdparse
Kennedy got killed
auxpass(killed, got)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/auxpass.md" target="#">edit auxpass</a>
</div>

<div about="#case_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#case" />
	<a id="al-en-dep/case" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">case</code>: <div property="rdfs:label">case marking</div></h2>
	<div property="rdfs:comment">

The `case` relation is used for any preposition in English. Prepositions are treated as dependents of the noun they attach to or introduce in an "extended nominal projection". Thus, contrary to SD, UD abandons treating a preposition as a mediator between a modified word and its object. The `case` relation aims at providing a uniform analysis of prepositions and case in morphologically rich languages. In English, subordinating conjunctions introducing clauses are often in the form of prepositions. However, they are given a different dependency: The relation [mark]() is used for markers in an "extended clausal projection".

The `case` relation is also used for the possessive clitic _'s_ in English, which we separate from what it modifies, because it acts as a phrasal clitic, as shown in the last example.

~~~ sdparse
I saw a cat in a hat
case(hat, in)
~~~

~~~ sdparse
I saw a cat with a telescope
case(telescope, with)
~~~

~~~ sdparse
He is responsible for meals
case(meals, for)
~~~

~~~ sdparse
The school 's grounds
case(school, 's)
~~~

~~~ sdparse
The head of school 's speech
case(head, 's)
case(school, of)
nmod(speech, head)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/case.md" target="#">edit case</a>
</div>

<div about="#cc_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#cc" />
	<a id="al-en-dep/cc" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cc</code>: <div property="rdfs:label">coordination</div></h2>
	<div property="rdfs:comment">

A coordination is the relation between an element of a conjunct and the coordinating conjunction word of the conjunct.  (Note: different dependency grammars have different treatments of coordination.  We take one conjunct of a conjunction (normally the first) as the head of the conjunction.) A conjunction may also appear at the beginning of a sentence.  This is also called a `cc`, and dependent on the root predicate of the sentence. 

~~~ sdparse
And then we left .
cc(left, And)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/cc.md" target="#">edit cc</a>
</div>

<div about="#cc%3Apreconj_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#cc" />
	<a id="al-en-dep/cc:preconj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cc:preconj</code>: <div property="rdfs:label">preconjunct</div></h2>
	<div property="rdfs:comment">

A preconjunct is the relation between the head of an NP and a word
that appears at the beginning bracketing a conjunction (and puts
emphasis on it), such as *either*, *both*, *neither*).

~~~ sdparse
Both the boys and the girls are here
cc:preconj(boys, Both)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/cc-preconj.md" target="#">edit cc:preconj</a>
</div>

<div about="#ccomp_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#ccomp" />
	<a id="al-en-dep/ccomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">ccomp</code>: <div property="rdfs:label">clausal complement</div></h2>
	<div property="rdfs:comment">

A clausal complement of a verb or adjective is a dependent clause with an internal subject which functions like an object of the verb or adjective.  

~~~ sdparse
He says that you like to swim
ccomp(says, like)
~~~

~~~ sdparse
I am certain that he did it 
ccomp(certain, did) 
mark(did, that) 
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/ccomp.md" target="#">edit ccomp</a>
</div>

<div about="#compound_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#compound" />
	<a id="al-en-dep/compound" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">compound</code>: <div property="rdfs:label">compound</div></h2>
	<div property="rdfs:comment">

*compound* is used for 

- noun compounds (Note that in the current system for dependency extraction, all nouns modify the rightmost noun of the noun phrase -- there is no intelligent noun compound analysis.  This is likely to be fixed once the Penn Treebank represents the branching structure of noun phrases.) 

~~~ sdparse
phone book
compound(book, phone)
~~~

~~~ sdparse
oil price futures
nn(futures, oil)
~~~

- numbers

~~~ sdparse
I have four thousand sheep
compound(thousand, four)
~~~

~~~ sdparse
I lost $ 3.2 billion
compound(billion, 3.2)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/compound.md" target="#">edit compound</a>
</div>

<div about="#compound%3Aprt_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#compound" />
	<a id="al-en-dep/compound:prt" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">compound:prt</code>: <div property="rdfs:label">phrasal verb particle</div></h2>
	<div property="rdfs:comment">

The phrasal verb particle relation identifies a phrasal verb, and
holds between the verb and its particle. It is a subtype of the
[compound]() relation.

~~~ sdparse
They shut down the station
compound:prt(shut, down)
~~~

~~~ sdparse
They shut the station down
compound:prt(shut, down)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/compound-prt.md" target="#">edit compound:prt</a>
</div>

<div about="#conj_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#conj" />
	<a id="al-en-dep/conj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">conj</code>: <div property="rdfs:label">conjunct</div></h2>
	<div property="rdfs:comment">

A conjunct is the relation between two elements connected by a
coordinating conjunction, such as *and*, *or*, etc.  We treat
conjunctions asymmetrically: The head of the relation is the first
conjunct and other conjunctions depend on it via the `conj` relation.

~~~ sdparse
Bill is big and honest
conj(big, honest)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/conj.md" target="#">edit conj</a>
</div>

<div about="#cop_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#cop" />
	<a id="al-en-dep/cop" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cop</code>: <div property="rdfs:label">copula</div></h2>
	<div property="rdfs:comment">

A copula is the relation between the complement of a copular verb and
the copular verb. Copular heads are avoided when possible.

~~~ sdparse
Bill is an honest man
cop(man, is)
nsubj(man, Bill)
amod(man, honest)
det(man, an)
~~~

Prepositional phrases are annotated similarly, the only difference being that
the nominal predicate has an additional case marker.

~~~ sdparse
Bill is from California
case(California, from)
cop(California, is)
nsubj(California, Bill)
~~~

When an adjective or adverb is being predicated of a nominal phrase, the
adjective/adverb is the root, the nominal phrase is the nsubj, and the
copula is the cop.

~~~ sdparse
Bill is honest
nsubj(honest, Bill)
cop(honest, is)
~~~

~~~ sdparse
It was yesterday
nsubj(yesterday, It)
cop(yesterday, was)
~~~

Prepositions may also project a cop dependent.

~~~ sdparse
The light is on
cop(on, is)
nsubj(on, light)
det(light, The)
~~~

In predicative wh-constructions, the fronted wh-word is the head, and the copula is 
another cop.

~~~ sdparse
What is that ?
cop(What, is)
nsubj(What, that)
~~~

However, whenever the copula has a clausal argument/adjunct, the copula becomes the root, so the cop relation is not used.

~~~ sdparse
It was because Bill is honest
nsubj(was, It)
mark(honest, because)
ccomp(was, honest)
nsubj(honest, Bill)
cop(honest, is)
~~~

~~~ sdparse
My question is : was that really true ?
nsubj(is, question)
ccomp(is, true)
cop(true, was)
nsubj(true, that)
advmod(true, really)
~~~

~~~ sdparse
This is to inform you of our decision
nsubj(is, This)
advcl(is, inform)
aux(inform, to)
dobj(inform, you)
nmod(inform, decision)
case(decision, of)
poss(decision, our)
~~~

Predicative "be" is the only verb recognized as a copula; other copula-like verbs,such as "become", "get", and "seem", are treated as regular raising verbs, and thus take xcomp arguments. Non-predicative uses of "be"--e.g., "be" when used in periphrastic verbal constructions, presentationals, or existentials--is annotated as an aux instead.
of a cop.

~~~ sdparse
Bill got rich
nsubj(got, Bill)
xcomp(got, rich)
~~~

~~~ sdparse
Bill is speaking
nsubj(speaking, Bill)
aux(speaking, is)
~~~

~~~ sdparse
Here are some bags
advmod(are, Here)
nsubj(are, bags)
det(bags, some)
~~~

~~~ sdparse
There 's a cow in the field
expl('s, There)
nsubj('s, cow)
det(cow, a)
nmod('s, field)
det(field, the)
case(field, in)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/cop.md" target="#">edit cop</a>
</div>

<div about="#csubj_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#csubj" />
	<a id="al-en-dep/csubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubj</code>: <div property="rdfs:label">clausal subject</div></h2>
	<div property="rdfs:comment">

A clausal subject is a clausal syntactic subject of a clause, i.e., the subject is itself a clause. The governor of this relation might not always be a verb: when the verb is a copular verb, the root of the clause is the complement of the copular verb. In the two following examples, *what she said* is the subject. 

~~~ sdparse
What she said makes sense
csubj(makes, said)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/csubj.md" target="#">edit csubj</a>
</div>

<div about="#csubjpass_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#csubjpass" />
	<a id="al-en-dep/csubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubjpass</code>: <div property="rdfs:label">clausal passive subject</div></h2>
	<div property="rdfs:comment">

A clausal passive subject is a clausal syntactic subject of a passive
clause. In the example below, *that she lied* is the subject.

~~~ sdparse
That she lied was suspected by everyone
csubjpass(suspected, lied)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/csubjpass.md" target="#">edit csubjpass</a>
</div>

<div about="#dep_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#dep" />
	<a id="al-en-dep/dep" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dep</code>: <div property="rdfs:label">dependent</div></h2>
	<div property="rdfs:comment">

A dependency is labeled as `dep` when a system is unable to determine
a more precise dependency relation between two words.  This may be
because of a weird grammatical construction, a limitation in the
Stanford Dependency conversion software, a parser error, or because of
an unresolved long distance dependency.

~~~ sdparse
Then , as if to show that he could , ...
dep(show, if)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/dep.md" target="#">edit dep</a>
</div>

<div about="#det_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#det" />
	<a id="al-en-dep/det" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">det</code>: <div property="rdfs:label">determiner</div></h2>
	<div property="rdfs:comment">

A determiner is the relation between the head of an NP and its determiner. 

~~~ sdparse
The man is here
det(man, The)
~~~

~~~ sdparse
Which book do you prefer ?
det(book, Which)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/det.md" target="#">edit det</a>
</div>

<div about="#det%3Apredet_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#det" />
	<a id="al-en-dep/det:predet" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">det:predet</code>: <div property="rdfs:label">predeterminer</div></h2>
	<div property="rdfs:comment">

A predeterminer is the relation between the head of an NP and a word
that precedes and modifies the meaning of the NP determiner.

~~~ sdparse
All the boys are here
det:predet(boys, All)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/det-predet.md" target="#">edit det:predet</a>
</div>

<div about="#discourse_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#discourse" />
	<a id="al-en-dep/discourse" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">discourse</code>: <div property="rdfs:label">discourse element</div></h2>
	<div property="rdfs:comment">

This is used for interjections and other discourse particles and elements (which are not clearly linked to the structure of the sentence, except in an expressive way). We generally follow the guidelines of what the Penn Treebanks count as an INTJ.  They define this to include: interjections (*oh*, *uh-huh*, *Welcome*), fillers (*um*, *ah*), and discourse markers (*well*, *like*, *actually*, but not *you know*). 

~~~ sdparse
Iguazu is in Argentina :)
discourse(is-2, :)-5)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/discourse.md" target="#">edit discourse</a>
</div>

<div about="#dislocated_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#dislocated" />
	<a id="al-en-dep/dislocated" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dislocated</code>: <div property="rdfs:label">dislocated elements</div></h2>
	<div property="rdfs:comment">

The `dislocated` relation is used for fronted or postposed elements
that do not fulfill the usual core grammatical relations of a
sentence. Dislocated elements are attached to the same governor as the dependent that they double for.

~~~ sdparse
This is our office , me and Sam
dislocated(office, me)
cc(me, and)
conj(me, Sam)
~~~

~~~ sdparse
The Mezza Luna : you should try it .
det(Luna-3, The-1)
compound(Luna-3, Mezza-2)
dislocated(it-8, Luna-3)
nsubj(try-7, you-5)
aux(try-7, should-6)
root(root-0, try-7)
dobj(try-7, it-8)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/dislocated.md" target="#">edit dislocated</a>
</div>

<div about="#dobj_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#dobj" />
	<a id="al-en-dep/dobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dobj</code>: <div property="rdfs:label">direct object</div></h2>
	<div property="rdfs:comment">

The direct object of a VP is the noun phrase which is the (accusative) object of the verb. 

~~~ sdparse
She gave me a raise
dobj(gave, raise)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/dobj.md" target="#">edit dobj</a>
</div>

<div about="#expl_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#expl" />
	<a id="al-en-dep/expl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">expl</code>: <div property="rdfs:label">expletive</div></h2>
	<div property="rdfs:comment">

This relation captures an existential *there* or *it* in extraposition constructions. There is further discussion and examples on the universal dependency page ([u-dep/expl]()).

~~~ sdparse
There is a ghost in the room
expl(is, There)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/expl.md" target="#">edit expl</a>
</div>

<div about="#foreign_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#foreign" />
	<a id="al-en-dep/foreign" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">foreign</code>: <div property="rdfs:label">foreign words</div></h2>
	<div property="rdfs:comment">

We use `foreign` to label sequences of foreign words. These are given
a linear analysis: the head is the first token in the foreign phrase.

~~~ sdparse
I guess that c' est la vie
nsubj(guess-2, I-1)
ccomp(guess-2, c'-4)
mark(c'-4, that-3)
foreign(c'-4, est-5)
foreign(c'-4, la-6)
foreign(c'-4, vie-7)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/foreign.md" target="#">edit foreign</a>
</div>

<div about="#goeswith_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#goeswith" />
	<a id="al-en-dep/goeswith" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">goeswith</code>: <div property="rdfs:label">goes with</div></h2>
	<div property="rdfs:comment">

This relation links two parts of a word that are separated in text
that is not well edited. We follow the treebank: The GW part is the
dependent and the head is in some sense the *main* part, often the
second part.

~~~ sdparse
They come here with out legal permission
goeswith(out-5, with-4)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/goeswith.md" target="#">edit goeswith</a>
</div>

<div about="#iobj_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#iobj" />
	<a id="al-en-dep/iobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">iobj</code>: <div property="rdfs:label">indirect object</div></h2>
	<div property="rdfs:comment">

The indirect object of a (verbal) predicate is the nominal which is the dative
object of the verb. The relation `iobj` is used for objects that are not direct
objects. It occurs only when there is a `dobj` or `ccomp` in the clause.

~~~ sdparse
She gave me a raise
iobj(gave, me)
~~~

Note that prepositional phrases are not considered core arguments in English,
hence in _she gave it to me_, the _to me_ part is attached as [nmod]() although
semantically it corresponds to the dative.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/iobj.md" target="#">edit iobj</a>
</div>

<div about="#list_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#list" />
	<a id="al-en-dep/list" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">list</code>: <div property="rdfs:label">list</div></h2>
	<div property="rdfs:comment">

The `list` relation is used for chains of comparable items. Web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences. Email signatures in particular contain these structures, in the form of contact information: the different contact information items are labeled as `list`; the key-value pair relations are labeled as [appos]().

In lists with more than two items, all items of the list shoud modify the first one.

~~~ sdparse
Steve Jones Phone: 555-9814 Email: jones@abc.edf
name(Steve-1, Jones-2)
list(Steve-1, Phone:-3)
list(Steve-1, Email:-5)
appos(Phone:-3, 555-9814-4)
appos(Email:-5, jones@abc.edf-6)
~~~

In an itemized or numbered list, we have been taking the item marker as a dependent of the head of the contentful list item. This appears to be better than the alternative.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/list.md" target="#">edit list</a>
</div>

<div about="#mark_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#mark" />
	<a id="al-en-dep/mark" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mark</code>: <div property="rdfs:label">marker</div></h2>
	<div property="rdfs:comment">

A marker is the word introducing a clause subordinate to another clause. For a complement clause, this will typically be *that* or *whether*. For an adverbial clause, the marker is typically a preposition like *before* or a subordinating conjunction fulfilling a similar role like *while* or *although*. The mark is a dependent of the subordinate clause head. 

~~~ sdparse
Forces engaged in fighting after insurgents attacked
mark(attacked, after)
~~~

~~~ sdparse
He says that you like to swim
mark(swim, that)
~~~

The infinitive marker *to* is analyzed as a `mark`.

~~~ sdparse
I tried to finish it
mark(finish, to)
~~~

When a a noun or a verb takes a prepositionally marked non-core argument (modifier) and that modifier is a clause, then we also label that prepositon as `mark` (as it would not seem reasonable to call it `case` when it is marking a clause). The result will commonly be a doubly marked clause.

~~~ sdparse
We have no useful information on whether users are at risk .
nsubj(have, We)
neg(information, no)
amod(information, useful)
dobj(have, information)
mark(risk, on)
mark(risk, whether)
nsubj(risk, users)
cop(risk, are)
case(risk, at)
acl(information, risk)
punct(have, .)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/mark.md" target="#">edit mark</a>
</div>

<div about="#mwe_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#mwe" />
	<a id="al-en-dep/mwe" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mwe</code>: <div property="rdfs:label">multi-word expression</div></h2>
	<div property="rdfs:comment">

The multi-word expression (modifier) relation is used for certain fixed grammaticized expressions with function words that behave like a single function word. Multiword expressions are annotated in a flat, head-initial structure,
in which all words in the expression modify the first one using the
`mwe` label.

At present, this relation is used inside the following expressions: 

*as well*

~~~ sdparse
I like dogs as well
advmod(like, as)
mwe(as, well)
~~~

*as well as*

~~~ sdparse
I like dogs as well as cats
mwe(as-4, well)
mwe(as-4, as-6)
cc(dogs, as-4)
~~~

*such as*

~~~ sdparse
I like fluffy animals , such as dogs
case(dogs, such)
mwe(such, as)
~~~


*due to* (and other forms, such as *d t* and *d/t*)

~~~ sdparse
He cried due to the fact that you hurt him
case(fact, due)
mwe(due, to)
~~~

*because of* (and other forms, such as *b c of* and *b/c of*)

~~~ sdparse
He cried because of you
case(you, because)
mwe(because, of)
~~~

*instead of*

~~~ sdparse
John went instead of Mary
mwe(instead, of)
case(Mary, instead)
~~~

~~~ sdparse
John left early instead of staying for the whole thing
mwe(instead, of)
mark(staying, instead)
~~~

*in case*

~~~ sdparse
I always back up my files in case my computer crashes
mwe(in, case)
mark(crashes, in)
~~~

~~~ sdparse
I always back up my files just in case
mwe(in, case)
advmod(back, in)
advmod(in, just)
~~~

*in case of*

~~~ sdparse
I always back up my files in case of a crash
mwe(in, case)
mwe(in, of)
case(crash, in)
~~~

*of course*

~~~ sdparse
I like dogs , of course
advmod(like, of)
mwe(of, course)
~~~

*so that*

~~~ sdparse
He cried so that you would feel bad
mark(feel, so)
mwe(so, that)
~~~

*more than* (when used synonymously with "over" in a quantity)

~~~ sdparse
More than 90 percent
advmod(percent, More)
mwe(More, than)
~~~

*less than* (when used synonymously with "under" in a quantity)

~~~ sdparse
Less than ten percent
advmod(percent, Less)
mwe(Less, than)
~~~

*up to* (when used in quantities)

~~~ sdparse
Up to fifty percent
mwe(Up, to)
advmod(percent, Up)
~~~

*according to*

~~~ sdparse
According to John
mwe(According, to)
case(John, According)
~~~

*in order*

~~~ sdparse
He cried in order to make you feel bad
mark(feel, in)
mwe(in, order)
~~~

~~~ sdparse
He cried in order that you might feel bad
mark(feel, in)
mwe(in, order)
~~~

~~~ sdparse
He cried in order for you to have something to feel bad about
mark(have, in)
mwe(in, order)
~~~

*rather than*

~~~ sdparse
I decided to get a dog rather than a cat
mwe(rather, than)
cc(rather, dog)
~~~

*at least* (when not used for quantities)

~~~ sdparse
At least I like dogs
mwe(At, least)
advmod(like, At)
~~~

*as if*

~~~ sdparse
It was as if he cried to make you feel bad
mwe(as, if)
mark(cried, as)
~~~

*prior to*

~~~ sdparse
John left prior to the meeting
mwe(prior, to)
case(meeting, prior)
~~~

*as to*

~~~ sdparse
As to whether I love dogs ...
mwe(As, to)
mark(love, As)
~~~

~~~ sdparse
As to my love of dogs ...
mwe(As, to)
case(love, As)
~~~

*kind of*

~~~ sdparse
I kind of like dogs
mwe(kind, of)
advmod(like, kind)
~~~

*whether or not*

~~~ sdparse
He 's crying whether or not you feel bad about it
mwe(whether, or)
mwe(whether, not)
mark(feel, whether)
~~~

*not to mention*

~~~ sdparse
This restaurant is pretty cheap with good food, not to mention their friendly staff
mwe(not, to)
mwe(not, mention)
cc(cheap, not)
conj(staff, cheap)
~~~

*as opposed to*

~~~ sdparse
John decided to leave early , as opposed to Mary
mwe(as, opposed)
mwe(as, to-9)
case(Mary, as)
~~~

*let alone*

~~~ sdparse
He could n't handle being hurt , let alone hurt by you
mwe(let, alone)
cc(hurt-6, alone)
conj(hurt-6, hurt-10)
~~~

*so as to*

~~~ sdparse
John left early so as to miss the meeting
mwe(so, as)
mwe(so, to)
mark(so, miss)
~~~

*in between*

~~~ sdparse
John left in between meetings
mwe(in, between)
case(in, meetings)
~~~

*all but*

~~~ sdparse
John has all but left
mwe(all, but)
advmod(all, left)
~~~

*that is*

~~~ sdparse
The dogs need to be housebroken -- that is , '' potty - trained ''
mwe(that, is)
advmod(trained, that)
~~~

*how come*

~~~ sdparse
How come John left early ?
mwe(How, come)
mark(left, How)
~~~

*had better* (and *'d better*)

~~~ sdparse
You had better apologize
mwe(had, better)
aux(had, apologize)
~~~

### Not `mwe`s
The following are **not** annotated as `mwe`s, but are instead labeled according to their apparent internal structure.

*out of*, *off of* (All double prepositions denoting spatial relations are annotated with two cases on the nominal)

~~~ sdparse
Get out of there !
nmod(Get, there)
case(there, out)
case(there, of)
~~~

~~~ sdparse
Get off of that !
nmod(Get, that)
case(that, off)
case(that, of)
~~~ 

*by far*

~~~ sdparse
Dogs are the best animal by far
nmod(animal, far)
case(far, by)
~~~

*what about*

~~~ sdparse
What about John ?
nmod(What, John)
case(John, about)
~~~

*at all*

~~~ sdparse
I don't like her at all
nmod(like, all)
case(all, at)
~~~

*at most*, *at least* (when used for quantities. To determine whether *at least* should be an `mwe` or not in borderline cases, substitute it with *at most*; if the sentence remains grammatical, it should receive its surface analysis)

~~~ sdparse
at most 50 percent
nmod:npmod(percent, most)
case(most, at)
~~~

~~~ sdparse
at least 50 percent
nmod:npmod(percent, least)
case(least, at)
~~~

*at best*, *at worst*

~~~ sdparse
At best , they were guesses
nmod:npmod(guesses, best)
case(best, At)
~~~

~~~ sdparse
At worst , they were lies
nmod:npmod(lies, worst)
case(worst, At)
~~~

*what if*

~~~ sdparse
What if John left early ?
advcl(What, left)
mark(left, if)
~~~

*so long*

~~~ sdparse
So long , Ham 's ... you will be missed
advmod(long, So)
vocative(long, Ham)
parataxis(long, missed)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/mwe.md" target="#">edit mwe</a>
</div>

<div about="#name_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#name" />
	<a id="al-en-dep/name" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">name</code>: <div property="rdfs:label">name</div></h2>
	<div property="rdfs:comment">

`name` is one of the three relations for compounding in UD (together
with [compound]() and [mwe]()).
It is used for proper nouns constituted of multiple nominal
elements. For example, `name` would be used between the words of
_Hillary Rodham Clinton, New York,_ or _Carl XVI Gustaf_ but not to
replace the usual relations in a phrasal or clausal name like _The
king of Sweden_ or the novels _The Lord of the Rings_ and _Captured By
Aliens._
Words joined by `name` should all be part of a minimal noun phrase;
otherwise regular syntactic relations should be used.  This is
basically similar to the treatment of noun compounds with
[compound](), except that in many cases parts of the name may be
another nominal element such as an adjective _(United Airlines)._

In general, names are annotated in a flat, head-initial structure, in
which all words in the name modify the first one using the `name`
label.

~~~ sdparse
Carl XVI Gustaf
name(Carl-1, Gustaf-3)
name(Carl-1, XVI-2)
~~~

For organization names with clear syntactic modification structure, the dependencies should reflect the syntactic modification structure using regular syntactic relation, as in:.

~~~ sdparse
Natural Resources Conservation Service
amod(Resources-2, Natural-1)
compound(Conservation-3, Resources-2)
compound(Service-4, Conservation-3)
~~~

In addition, regular syntactic relations are used:
(i) for a modifying determiner or
(ii) to connect together the words of a description or name which involve embedded prepositional phrases, sentences, etc.

~~~ sdparse
Le Japon
det(Japon-2, Le-1)
~~~

~~~ sdparse
Ludwig van Beethoven
case(Beethoven, van)
~~~

~~~ sdparse
Miguel de Cervantes y Saavedra
conj(Cervantes, Saavedra)
cc(Cervantes, y)
case(Cervantes, de)
~~~

~~~ sdparse
The king of Sweden
det(king-2, The-1)
nmod(king-2, Sweden-4)
case(Sweden-4, of-3)
~~~

~~~ sdparse
Río de la Plata
case(Plata-4, de-2)
det(Plata-4, la-3)
nmod(Río-1, Plata-4)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/name.md" target="#">edit name</a>
</div>

<div about="#neg_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#neg" />
	<a id="al-en-dep/neg" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">neg</code>: <div property="rdfs:label">negation modifier</div></h2>
	<div property="rdfs:comment">

The negation modifier is the relation between a negation word and the
word it modifies. It is used both for predicate negation (canonically, _not_) and nominal negation (canonically _no_). Dependents labeled `neg` in the current treebank are the following (in various lowercase/uppercase forms): _n, n't, neither, never, no, non, not, nt, t_. 

~~~ sdparse
Bill is not a scientist
neg(scientist, not)
~~~

~~~ sdparse
Bill does n't drive
neg(drive, n't)
~~~

~~~ sdparse
John saw no accidents
neg(accidents, no)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/neg.md" target="#">edit neg</a>
</div>

<div about="#nmod_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-en-dep/nmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod</code>: <div property="rdfs:label">nominal modifier</div></h2>
	<div property="rdfs:comment">

The `nmod` relation is used for nominal modifiers of nouns or clausal
predicates. `nmod` is a noun functioning as a non-core (oblique)
argument or adjunct. In English, `nmod` is used

- for prepositional complements:

~~~ sdparse
the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
~~~

~~~ sdparse
give the toys to the children
dobj(give, toys)
nmod(give, children)
case(children, to)
~~~

The `nmod` relation holds between the noun/predicate modified by the
prepositional complement and the noun introduced by the preposition.

- for 's genitives:

~~~ sdparse
the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
~~~

Nominal modifiers not introduced by a preposition or not 's genitives
are tagged [nmod:npmod](), a subtype of `nmod`. Temporal nominal
modifiers are also marked with a separate relation [nmod:tmod](). See
the definitions of these relations.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod.md" target="#">edit nmod</a>
</div>

<div about="#nmod%3Anpmod_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-en-dep/nmod:npmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:npmod</code>: <div property="rdfs:label">noun phrase as adverbial modifier</div></h2>
	<div property="rdfs:comment">

This relation is a subtype of the [nmod]() relation, which captures
the following cases where something syntactically a noun phrase is
used as an adverbial modifier in a sentence:


(i) a measure phrase, which is the relation between the head of an adjectival/adverbial or prepositional phrase and the head of a measure phrase modifying it:

~~~ sdparse
The director is 65 years old
nmod:npmod(old, years)
~~~

~~~ sdparse
6 feet long
nmod:npmod(long, feet)
~~~


(ii) noun phrases giving an extent to a verb, which are not objects:

~~~ sdparse
Shares eased a fraction
nmod:npmod(eased, fraction)
~~~


(iii) financial constructions involving an adverbial, notably the following construction *$5 a share*, where the second nominal means "per share":

~~~ sdparse
IBM earned $ 5 a share
nmod:npmod($, share)
~~~


(iv) floating reflexives

~~~ sdparse
The silence is itself significant
nmod:npmod(significant, itself)
~~~

and (v) certain other absolutive nominal constructions.

A temporal modifier [nmod:tmod]() is a subclass of npmod which is
distinguished as a separate relation.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod-npmod.md" target="#">edit nmod:npmod</a>
</div>

<div about="#nmod%3Aposs_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-en-dep/nmod:poss" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:poss</code>: <div property="rdfs:label">possessive nominal modifier</div></h2>
	<div property="rdfs:comment">

`nmod:poss` is used for a nominal modifier which occurs before its head in the specifier position used for _'s_ possessives. It is marked with the `case` _'s_ or one of its variant forms. This relation isn't used for other pre-head modifiers such as noun compounds or quotative phrases.

~~~ sdparse
Marie 's book
nmod:poss(book, Marie)
case(Marie, 's)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod-poss.md" target="#">edit nmod:poss</a>
</div>

<div about="#nmod%3Atmod_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-en-dep/nmod:tmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:tmod</code>: <div property="rdfs:label">temporal modifier</div></h2>
	<div property="rdfs:comment">

A temporal modifier is a subtype of the [nmod]() relation: if the modifier is specifying a time, it is labeled as *tmod*. 

~~~ sdparse
Last night , I swam in the pool
nmod:tmod(swam, night)
~~~

~~~ sdparse
You need to turn in your homework by next week
nmod:tmod(turn, week)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod-tmod.md" target="#">edit nmod:tmod</a>
</div>

<div about="#nsubj_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubj" />
	<a id="al-en-dep/nsubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubj</code>: <div property="rdfs:label">nominal subject</div></h2>
	<div property="rdfs:comment">

A nominal subject (`nsubj`) is a nominal which is the syntactic subject and the proto-agent of a clause.
That is, it is in the position that passes typical grammatical test for subjecthood, and this argument is the more agentive,
the do-er, or the proto-agent of the clause. 
(See [csubj]() for when the subject is clausal. See [nsubjpass]() and [csubjpass]() for when the subject is not 
the proto-agent argument due to valence changing operations.) This nominal may be headed by a noun, 
or it may be a pronoun or relative pronoun, or in ellipsis contexts, other things such as an adjective.

The `nsubj` role is only applied to semantic arguments of a predicate.
When there is an empty argument in a grammatical subject position (sometimes called a pleonastic or expletive),
it is labeled as [expl](). If there is then a displaced subject
in the clause, as in the English existential _there_ construction, it will be labeled as `nsubj`.
The governor of the `nsubj` relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun, including a noun marked by a preposition,
as in the examples below.

In English, the `nsubj` normally precedes the predicate that it depends on, but this need not be the case, 
both for the displaced subjects of expletive constructions and in other cases of stylistic inversion, such
as the example headed by the predicate _come_ below.

~~~ sdparse
Clinton defeated Dole
nsubj(defeated, Clinton)
~~~

~~~ sdparse
The car is red .
nsubj(red, car)
~~~

~~~ sdparse
Sue is a true patriot .
nsubj(patriot, Sue)
~~~

~~~ sdparse
We are in the barn .
nsubj(barn, We)
~~~

~~~ sdparse
Agatha is in trouble .
nsubj(trouble, Agatha)
~~~

~~~ sdparse
There is a ghost in the room .
expl(is, There)
nsubj(is, ghost)
~~~

~~~sdparse
These links present the many viewpoints that existed .
acl:relcl(viewpoints, existed)
nsubj(existed, that)
~~~

~~~sdparse
From China comes news of a new super-small mobile phone .
nsubj(comes, news)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nsubj.md" target="#">edit nsubj</a>
</div>

<div about="#nsubjpass_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubjpass" />
	<a id="al-en-dep/nsubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubjpass</code>: <div property="rdfs:label">passive nominal subject</div></h2>
	<div property="rdfs:comment">

A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.

~~~ sdparse
Dole was defeated by Clinton
nsubjpass(defeated, Dole)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nsubjpass.md" target="#">edit nsubjpass</a>
</div>

<div about="#nummod_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#nummod" />
	<a id="al-en-dep/nummod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nummod</code>: <div property="rdfs:label">numeric modifier</div></h2>
	<div property="rdfs:comment">

A numeric modifier of a noun is any number phrase that serves to
modify the meaning of the noun with a quantity.

~~~ sdparse
Sam ate 3 sheep
nummod(sheep, 3)
~~~

~~~ sdparse
Sam spent forty dollars
nummod(dollars, forty)
~~~

~~~ sdparse
Sam spent $ 40
nummod($, 40)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nummod.md" target="#">edit nummod</a>
</div>

<div about="#parataxis_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#parataxis" />
	<a id="al-en-dep/parataxis" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">parataxis</code>: <div property="rdfs:label">parataxis</div></h2>
	<div property="rdfs:comment">

The parataxis relation (from Greek for "place side by side") is a relation between the main verb of a clause and other sentential elements, such as a sentential parenthetical, a clause after a ":" or a ";", or two sentences placed side by side without any explicit coordination or subordination. 

~~~ sdparse
Let 's face it we 're annoyed
parataxis(Let, annoyed)
~~~

When multiple parataxes are present in a single sentence, they get a flat structure, not a hierarchical one, even if they form a temporal sequence.

~~~ sdparse
ROOT I 'm not kidding , I once lost a hamster in my house , three months later I walk down in the basement and it was as big as a rat .
root(ROOT, kidding)
parataxis(lost, kidding)
parataxis(walk, kidding)
~~~

All else being equal, the leftmost phrase should be the head, but in rare situations the parataxis can go ``backwards'':

~~~ sdparse
The guy , John said , left early in the morning
parataxis(left, said)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/parataxis.md" target="#">edit parataxis</a>
</div>

<div about="#punct_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#punct" />
	<a id="al-en-dep/punct" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">punct</code>: <div property="rdfs:label">punctuation</div></h2>
	<div property="rdfs:comment">

This is used for any piece of punctuation in a clause, if punctuation is being retained in the typed dependencies. By default, punctuation is not retained in the output. 

~~~ sdparse
Go home !
punct(Go, !)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/punct.md" target="#">edit punct</a>
</div>

<div about="#remnant_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#remnant" />
	<a id="al-en-dep/remnant" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">remnant</code>: <div property="rdfs:label">remnant in ellipsis</div></h2>
	<div property="rdfs:comment">

The `remnant` relation is used to provide a satisfactory treatment of ellipsis (in
the case of gapping and stripping, where a predicational or verbal
head gets elided) *without* having to postulate empty nodes in the basic representation. This is something that was lacking in earlier versions
of SD and provides a basis for being able to reconstruct dependencies
in the enhanced representation of SD. 

USD adopts an analysis that notes that in ellipsis a `remnant` corresponds to a *correlate* in a preceding clause. The `remnant` relation connects each remnant to its correlate in the basic dependency representation. This is then a sufficient representation to reconstruct the predicate-argument structure in the enhanced representation.

~~~ sdparse
Marie went to Paris and Miriam to Prague
nsubj(went-2, Marie-1)
root(root-0, went-2)
nmod(went-2, Paris-4)
case(Paris-4, to-3)
cc(went-2, and-5)
remnant(Marie-1, Miriam-6)
case(Prague-8, to-7)
remnant(Paris-4, Prague-8)
~~~

Even in the more complex example below, the `remnant`
relations enable us to correctly retrieve the subjects and objects in
the clauses with an elided verb.

~~~ sdparse
John won bronze , Mary silver , and Sandy gold
nsubj(won-2, John-1)
dobj(won-2, bronze-3)
remnant(John-1, Mary-5)
remnant(Mary-5, Sandy-9)
remnant(bronze-3, silver-6)
remnant(silver-6, gold-10)
~~~

Note in particular that (unlike for [conj]()), `remnant` uses a chaining analysis where each subsequent remnant depends on the immediately preceding remnant/correlate. The reason for this is that otherwise in a sentence with 2 or more chained ellipses the dependency structure would no longer track which remnants go together. It would become impossible to determine whether Mary won silver and Sandy gold, or Mary won gold and Sandy silver.

Instances of stripping typically occur when there is only one argument in the second clause, but with an accompanying adverbial modifier such as *not* or *only*. We model these sentences with the remnant relation as well.

~~~ sdparse
Marie went to Paris , not Miriam
nsubj(went-2, Marie-1)
root(root-0, went-2)
nmod(went-2, Paris-4)
case(Paris-4, to-3)
remnant(Marie-1, Miriam-7)
neg(Miriam-7, not-6)
~~~

~~~ sdparse
Marie did go to Europe , but only to Paris .
nsubj(go-3, Marie-1)
aux(go-3, did-2)
root(root-0, go-3)
case(Europe-5, to-4)
nmod(go-3, Europe-5)
cc(go-3, but-7)
advmod(Paris-10, only-8)
case(Paris-10, to-9)
remnant(Europe-5, Paris-10)
~~~

Sometimes in these constructions adverbials will be "sprouted", and have no correlate in the precedeing clause. In such a situation, the adverbial should attach to one of the remnants; in principle it shouldn't matter which remnant it attaches to, since all remnants at a particular depth of embedding point back to the same semantic event (which the adverbial is a part of). However, to enforce a regular system, the adverbial should depend on the nearest leftmost dependent. 

~~~ sdparse
Mary will come today and Tom tomorrow , if he finds a ticket .
nsubj(come-3, Mary-1)
aux(come-3, will-2)
root(root-0, come-3)
advmod(come-3, today-4)
cc(come-3, and-5)
remnant(Mary-1, Tom-6)
remnant(today-4, tomorrow-7)
mark(finds-11, if-9)
nsubj(finds-11, he-10)
advcl(tomorrow-7, finds-11)
det(ticket-13, a-12)
dobj(finds-11, ticket-13)
~~~

~~~ sdparse
Mary will come today and , if he finds a ticket , Tom tomorrow .
nsubj(come-3, Mary-1)
aux(come-3, will-2)
root(root-0, come-3)
advmod(come-3, today-4)
cc(come-3, and-5)
mark(finds-9, if-7)
nsubj(finds-9, he-8)
advcl(Tom-13, finds-9)
det(ticket-11, a-10)
dobj(finds-9, ticket-11)
remnant(Mary-1, Tom-13)
remnant(today-4, tomorrow-14)
~~~

The `remnant` relation is used when no predicational material is present. In contrast, in right-node-raising (RNR) and VP-ellipsis constructions in which some kind of predicational or verbal material is still present, the `remnant` relation is not used. In RNR, the verbs are coordinated and the object is a [dobj]() of the first verb:

~~~ sdparse
John bought and ate an apple
nsubj(bought-2, John-1)
cc(bought-2, and-3)
conj(bought-2, ate-4)
det(apple-6, an-5)
dobj(bought-2, apple-6)
~~~

In VP-ellipsis, we keep the auxiliary as the head, as shown below:

~~~ sdparse
John will win gold and Mary will too
nsubj(win-3, John-1)
aux(win-3, will-2)
dobj(win-3, gold-4)
cc(win-3, and-5)
conj(win-3, will-7)
nsubj(will-7, Mary-6)
advmod(will-7, too-8)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/remnant.md" target="#">edit remnant</a>
</div>

<div about="#reparandum_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#reparandum" />
	<a id="al-en-dep/reparandum" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">reparandum</code>: <div property="rdfs:label">overridden disfluency</div></h2>
	<div property="rdfs:comment">

We use `reparandum` to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair.

~~~ sdparse
Go to the righ- to the left .
nmod(Go-1, left-7)
reparandum(left-7, righ-)
case(righ-, to-2)
det(righ-, the-3)
case(left-7, to-5)
det(left-7, the-6)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/reparandum.md" target="#">edit reparandum</a>
</div>

<div about="#root_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#root" />
	<a id="al-en-dep/root" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">root</code>: <div property="rdfs:label">root</div></h2>
	<div property="rdfs:comment">

The `root` grammatical relation points to the root of the sentence. A fake node "ROOT" is used as the governor. The ROOT node is indexed with "0", since the indexation of real words in the sentence starts at 1. 

~~~ sdparse
ROOT I love French fries .
root(ROOT, love)
~~~

~~~ sdparse
ROOT Bill is an honest man
root(ROOT, man)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/root.md" target="#">edit root</a>
</div>

<div about="#vocative_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#vocative" />
	<a id="al-en-dep/vocative" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">vocative</code>: <div property="rdfs:label">vocative</div></h2>
	<div property="rdfs:comment">

The `vocative` relation is used to mark dialogue participant addressed
in text (common in emails and newsgroup postings). The relation links
the addressee's name to its host sentence.

~~~ sdparse
Guys , take it easy!
vocative(take, Guys)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/vocative.md" target="#">edit vocative</a>
</div>

<div about="#xcomp_en" property="rdf:type" resource="#dep_en">
	<div property="rdf:type" resource="../../u/dep/all.html#xcomp" />
	<a id="al-en-dep/xcomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">xcomp</code>: <div property="rdfs:label">open clausal complement</div></h2>
	<div property="rdfs:comment">

An open clausal complement (`xcomp`) of a verb or an adjective is a predicative or clausal complement without its own subject. The reference of the subject is necessarily determined by an argument external to the xcomp (normally by the object of the next higher clause, if there is one, or else by the subject of the next higher clause. These complements are always non-finite, and they are complements (arguments of the higher verb or adjective) rather than adjuncts/modifiers, such as a purpose clause. The name `xcomp` is borrowed from Lexical-Functional Grammar. 

~~~ sdparse
He says that you like to swim
xcomp(like, swim)
~~~

~~~ sdparse
Sue asked George to respond to her offer
xcomp(asked, respond)
~~~

~~~ sdparse
I consider him a fool
xcomp(consider, fool)
~~~

~~~ sdparse
I consider him honest
xcomp(consider, honest)
~~~
 
~~~ sdparse
She looks very beautiful
xcomp(looks, beautiful)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/xcomp.md" target="#">edit xcomp</a>
</div>



      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html
	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'en-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
