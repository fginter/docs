<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml"
	prefix:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
	prefix:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
	prefix:oliasystem="http://purl.org/olia/system.owl#"
	prefix:xsd="http://www.w3.org/2001/XMLSchema#"
>

  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Dependencies</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
	
          <span class="header-text"><a href="http://universaldependencies.org/#language-tr">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          
<h1 id="dependencies">Dependencies</h1>

<p><span about="." property="rdf:type" resource="owl:Ontology">
	<span property="owl:imports" resource=" https://www.w3.org/2012/pyRdfa/extract?uri=http://universaldependencies.org/docs/u/dep/all.html&amp;format=xml&amp;rdfagraph=output&amp;vocab_expansion=false&amp;rdfa_lite=false&amp;embedded_rdf=true&amp;space_preserve=false&amp;vocab_cache=true&amp;vocab_cache_report=false&amp;vocab_cache_refresh=false"></span>
</span></p>

<p>Note: <i>nmod</i>, <i>neg</i>, and <i>punct</i> appear
in two places.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a>nsubj</a></td>
	  <td><a>csubj</a></td>
	</tr>
	<tr>
	  <td><a>nsubjpass</a></td>
	  <td><a>csubjpass</a></td>
	</tr>
	<tr>
	  <td><a>dobj</a></td>
	  <td><a>ccomp</a></td>
	  <td><a>xcomp</a></td>
	</tr>
	<tr>
	  <td><a>iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Non-core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td><a>advcl</a></td>
	  <td><a>advmod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Special clausal dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a>vocative</a></td>
	  <td><a>aux</a></td>
	  <td><a>mark</a></td>
	</tr>
	<tr>
	  <td><a>discourse</a></td>
	  <td><a>auxpass</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>expl</a></td>
	  <td><a>cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Noun dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nummod</a></td>
	  <td><a>acl</a></td>
	  <td><a>amod</a></td>
	</tr>
	<tr>
	  <td><a>appos</a></td>
	  <td>&nbsp;</td>
	  <td><a>det</a></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Compounding and unanalyzed</strong></td></tr>
	<tr>
	  <td><a>compound</a></td>
	  <td><a>mwe</a></td>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td><a>name</a></td>
	  <td><a>foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Coordination</strong></td></tr>
	<tr>
	  <td><a>conj</a></td>
	  <td><a>cc</a></td>
	  <td><a>punct</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Case-marking, prepositions, possessive</strong></td></tr>
	<tr>
	  <td><a>case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Loose joining relations</strong></td></tr>
	<tr>
	  <td><a>list</a></td>
	  <td><a>parataxis</a></td>
	  <td><a>remnant</a></td>
	</tr>
	<tr>
	  <td><a>dislocated</a></td>
	  <td></td><td><a>reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Other</strong></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<p><span about="#dep_tr" property="rdfs:label" style="visibility: hidden">Dependencies</span>
<span about="#dep_tr" property="rdfs:subClassOf" resource="_:tr">
	<span about="_:tr" property="rdf:type" resource="owl:Restriction">
		<span property="owl:onProperty" resource="http://purl.org/dc/terms/language"></span>
		<span property="owl:hasValue" lang="" style="visibility: hidden">tr</span>
	</span>
</span></p>

<hr />

<div about="#acl_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#acl" />
	<a id="al-tr-dep/acl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">acl</code>: <div property="rdfs:label">clausal modifier of noun</div></h2>
	<div property="rdfs:comment">

`acl` stands for finite and non-finite clauses that modify a nominal. 
The head of the `acl` relation is the noun that is modified, 
and the dependent is the head of the clause that modifies the noun.

Like non-clausal adjectives, most adjectival clauses in Turkish precede the noun they modify.
The only exception is the adjectival clauses formed by _ki_
that is similar to English relative pronouns "which" or "who" (not to be confused by suffix _-ki_).

The primary means of subordination, including forming adjectival clauses,
is through the subordinating suffixes attached to the head of the subordinate clause.
The adjectival clauses formed by _-ki_ is not as frequent and cover only a limited range uses of adjectival clauses.

~~~ sdparse
Ali'nin okuduğu kitap \n The book that Ali is reading
acl(kitap, okuduğu)
~~~

~~~ sdparse
Ali , ki çok kitap okur , henüz son kitabını okumamış. \n Ali, who reads a lot, hasn't read your last book yet
acl(Ali, okur)
mark(okur, ki)
~~~

Almost all adjectival clauses in Turkish are relative clauses.
There are only a few marginal constructions where a pronoun referring to the modified noun can be present in the subordinate clause.

~~~ sdparse
Ali , ki onu\/kendisini üç gündür görmüyorduk , evde kitap okuyormuş \n Ali, who we haven't been seeing (him\/himself) for three days, has apparently been reading books at home
acl(Ali, görmüyorduk)
mark(görmüyorduk, ki)
~~~

We currently do not mark (non-)relative clauses differently.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/acl.md" target="#">edit acl</a>
</div>

<div about="#advcl_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#advcl" />
	<a id="al-tr-dep/advcl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advcl</code>: <div property="rdfs:label">adverbial clause modifier</div></h2>
	<div property="rdfs:comment">

An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.), as a modifier not as a core complement. 
This includes things such as a temporal clause, consequence, conditional clause, purpose clause, etc.
The dependent must be clausal (or else it is an [advmod]()) and the dependent is the main predicate of the clause.

Note that we treat the conditional clauses specially and mark then with a subtype: [advcl:cond](advcl-cond).

Turkish adverbial clauses are mainly formed by a set of [converb](https://en.wikipedia.org/wiki/Converb)ial suffixes.

~~~ sdparse
Ali gelince sevindi . \n He\/she became happy when Ali arrived
advcl(sevindi, gelince)
~~~

~~~ sdparse
Okurken uyuyakalmışım . \n I fell asleep while reading
advcl(uyuyakalmışım, Okurken)
~~~

The subordinator _ki_ and a few other subordinating words may also form adverbial clauses.

~~~ sdparse
Bu kitabı sen de okursun diye aldım \n I bought this book so that you would read it too
advcl(aldım, okursun)
mark(okursun, diye)
~~~

~~~ sdparse
Bu kitabı aldım ki sen de okuyasın \n I bought this book so that you would read it too
advcl(aldım, okuyasın)
mark(okuyasın, ki)
~~~

~~~ sdparse
Bu kitabı okudun mu herşeyi anlayacaksın \n You will understand everything once you have read this book
advcl(anlayacaksın, okudun)
mark(okudun, mu)
~~~

A large number of adverbials and adverbial clauses are formed by postpositions attached to nouns or noun clauses.
We do not mark these as adverbial (`advmod` or `advcl`).
For both cases we use [nmod](nmod) (see discussion of subordination
in [tr-overview/specific-syntax]()).





	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/advcl.md" target="#">edit advcl</a>
</div>

<div about="#advcl%3Acond_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#advcl" />
	<a id="al-tr-dep/advcl:cond" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advcl:cond</code>: <div property="rdfs:label">conditional adverbial clause modifier</div></h2>
	<div property="rdfs:comment">

This relation is a subtype of [advcl]().
It is used for conditional clauses.

~~~ sdparse
Kitabı okusaydın anlardın . \n You would understand if you had read the book
advcl:cond(anlardın, okusaydın)
~~~

In Turkish conditional clauses are formed by a verbal inflection on the head of the clause. 
There are also two redundant words, _eğer_ and _şayet_ that may be included at the beginning or end of the phrase.
Use of these words are only for emphasis or an early signal that a conditional clause follows.
We use [discourse]() (not [mark]()) for marking the relation between these words and head of the conditional clause.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/advcl-cond.md" target="#">edit advcl:cond</a>
</div>

<div about="#advmod_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#advmod" />
	<a id="al-tr-dep/advmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advmod</code>: <div property="rdfs:label">adverbial modifier</div></h2>
	<div property="rdfs:comment">

An adverbial modifier of a word is a (non-clausal) [adverb](tr-pos/ADV) or adverbial phrase that serves to modify the meaning of the word.

Note that nouns in particular morphological [cases](tr-feat/Case),
or followed by and [adposition](tr-pos/ADP) are marked using [nmod]() even if they function as adverbial modifiers.

~~~ sdparse
Çok iyi bir kitap \n A very good book
advmod(iyi, Çok)
~~~

~~~ sdparse
Sürekli konuşuyorlar \n They are talking continuously
advmod(konuşuyorlar, Sürekli)
~~~

We use a special label, [tr-dep/advmod:emph]() for adverbial modifiers that are used for emphasis.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/advmod.md" target="#">edit advmod</a>
</div>

<div about="#advmod%3Aemph_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#advmod" />
	<a id="al-tr-dep/advmod:emph" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advmod:emph</code>: <div property="rdfs:label">emphasizing word, intensifier</div></h2>
	<div property="rdfs:comment">

This is a subtype of  [advmod](). 
It used for (non-clausal) modifiers that emphasize or intensify their heads.

~~~ sdparse
Çok da güzel bir kızmış \n She was (apparently) a very (very) beautiful girl.
admod:emph(Çok, da)
admod(güzel, Çok)
~~~

~~~ sdparse
Güzel mi güzel bir kız \n A very (very,very) beautiful girl
advmod:emph(Güzel-1, mi)
~~~

~~~ sdparse
Kitabı bile okumamış \n He (apparently) hasn't even read the book
admod:emph(okumamış, bile)
~~~

~~~ sdparse
İlk kitabı bile okumamış \n He (apparently) hasn't read even the book
admod:emph(kitabı, bile)
~~~




	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/advmod-emph.md" target="#">edit advmod:emph</a>
</div>

<div about="#amod_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#amod" />
	<a id="al-tr-dep/amod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">amod</code>: <div property="rdfs:label">adjectival modifier</div></h2>
	<div property="rdfs:comment">

An adjectival modifier of a noun is any adjectival phrase that serves to modify the meaning of the noun.

`amod` is not used for all modifiers of nouns.
We use [det]() for determiners (tagged tr[-pos/DET]()),
and for so-called "bare noun compounds" we use [compound]().

~~~ sdparse
Ali kırmızı şarap sever . \n Ali likes red wine
amod(şarap, kırmızı)
~~~

~~~ sdparse
Kıza kırmızı bir gül verdi . \n He gave the girl a red rose .
amod(gül, kırmızı)
det(gül, bir)
~~~

~~~ sdparse
Büyük tahta kapının önünde bekliyordu . \n He\/she was waiting in front of the big wooden door
amod(kapının, büyük)
compound(kapının, tahta)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/amod.md" target="#">edit amod</a>
</div>

<div about="#appos_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#appos" />
	<a id="al-tr-dep/appos" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">appos</code>: <div property="rdfs:label">appositional modifier</div></h2>
	<div property="rdfs:comment">

An appositional modifier of a noun is a nominal immediately following
the first noun that serves to define or modify that noun. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.


~~~ sdparse
Ali , en iyi arkadaşım , beni partiye davet etmedi . \n Ali, my best friend, did not invite me to the party .
appos(Ali, arkadaşım)
~~~

~~~ sdparse
Devlet Tiyatroları ( DT ) \n State Theatre ( DT )
appos(Tiyatroları, DT)
~~~

*appos* is also used to link key-value pairs in addresses, signatures,
etc. (see also the [list]() label):

~~~ sdparse
Ali Yılmaz ,  tel : 555-55-55 , email : ali@example.com
name(Ali, Yılmaz)
list(Ali, tel)
list(Ali, email)
appos(tel, 555-55-55)
appos(email, ali@example.com)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/appos.md" target="#">edit appos</a>
</div>

<div about="#aux_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#aux" />
	<a id="al-tr-dep/aux" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">aux</code>: <div property="rdfs:label">auxiliary</div></h2>
	<div property="rdfs:comment">

An auxiliary of a clause is a [non-main verb](tr-pos/AUX) of the clause.

In Turkish two verbs, _ol-_ and, in formal registers, _bulun_,
complement the main verb with additional tense/aspect/modality suffixes
that cannot be attached to the main verb due to morphological restrictions
(or sometimes stylistic reasons).

The auxiliary use of _ol-_ is different than its use as a copula,
where the [cop]() relation is used.

We use a subtype of `aux`, [aux:q](aux-q), question particle _mi_.

~~~ sdparse
Yarın çalışıyor olacak . \n He\/she will be working tomorrow
aux(çalışıyor, olacak)
~~~

~~~ sdparse
Okumuş olsa bilirdi . \n He would know if he had read (it) .
aux(Okumuş, olsa)
~~~

~~~ sdparse
Sorumluluğu almış bulunduk . \n He have taken the responsibility
aux(almış, bulunduk)
~~~

We also use `aux` in case bound auxiliary `-abil` is separated from the main verb.

~~~ sdparse
Göremeye de bilirdin . \n You might have also not seen it 
aux(Göremeye, bilirdin)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/aux_.md" target="#">edit aux</a>
</div>

<div about="#aux%3Aq_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#aux" />
	<a id="al-tr-dep/aux:q" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">aux:q</code>: <div property="rdfs:label">question particle</div></h2>
	<div property="rdfs:comment">

This is a subtype of [aux](), used for question particle _-mI (mı/mi/mu/mü)_.

The question particle, when attached to a predicate,
typically carries some of the tense/aspect/modality suffixes as well as person/number agreement suffixes.

Although it does not function as an auxiliary when attached to non-predicate words or phrases,
we use `aux:q` for all uses of the question particle.

**Annotation of question particles are not well-specified in UD, and currently under discussion.**

~~~ sdparse
Okuyacak mısınız ? \n Are you going to read ?
aux:q(Okuyacak, mısınız)
~~~

~~~ sdparse
Kitabı Ali'den aldın mı ? \n _Did_ you take the book from Ali ?
aux:q(aldın, mı)
~~~

~~~ sdparse
Kitabı Ali'den mi aldın ? \n Did you take the book _from Ali_ ?
aux:q(Ali'den, mi)
~~~

~~~ sdparse
Kitabı mı Ali'den aldın ? \n Did you take _the book_ from Ali ?
aux:q(Kitabı, mı)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/aux-q.md" target="#">edit aux:q</a>
</div>

<div about="#auxpass_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#auxpass" />
	<a id="al-tr-dep/auxpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">auxpass</code>: <div property="rdfs:label">passive auxiliary</div></h2>
	<div property="rdfs:comment">

We do not use `auxpass`


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/auxpass.md" target="#">edit auxpass</a>
</div>

<div about="#case_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#case" />
	<a id="al-tr-dep/case" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">case</code>: <div property="rdfs:label">case marking</div></h2>
	<div property="rdfs:comment">

The case relation is used for any case-marking element which is
treated as a separate syntactic word (including prepositions,
postpositions, and clitic case markers). Case-marking elements are
treated as dependents of the noun or clause they attach to.

In Turkish, case marking is typically done through suffixation,
in which case the case-marked word will carry the appropriate [Case](tr-feat/Case) feature.
The `case` relation marks postpositions,
and some of the case-like suffixes that are tokenized as separate syntactic tokens (inflectional groups).

~~~ sdparse
Ağaçların arasında kayboldular . \n They disappeared _between_ the trees
case(Ağaçların, arasında)
~~~

~~~ sdparse
Bu kitabı annem için aldım . \n I bought this book _for_ my mother
case(annem, için)
~~~

~~~ sdparse
Öğleden sonra dersim var . \n I have a class _after_ noon (=in the afternoon)
case(Öğleden, sonra)
~~~

~~~ sdparse
İkiye kadar bunu bitirmem gerek \n I need to finish this until\/by two
case(İkiye, kadar)
~~~

~~~ sdparse
Siyah saç –lı kız \n The girl _with_ black hair
case(saç, –lı)
~~~

Currently, we also use `case` for some not-so-case-like modifiers.

~~~ sdparse
Arabada –ki kız \n The girl in the car
case(Arabada, –ki)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/case.md" target="#">edit case</a>
</div>

<div about="#cc_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#cc" />
	<a id="al-tr-dep/cc" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cc</code>: <div property="rdfs:label">coordinating conjunction</div></h2>
	<div property="rdfs:comment">

A `cc` is the relation between the first conjunct and the [coordinating conjunction](../pos/CONJ) delimiting another conjunct.

Note that we currently diverge from UD specification by marking the last conjunct as the head.
See the [conj]() relation, for more information.

~~~ sdparse
Elma ve armut aldık . \n We both apples and oranges .
cc(armut, ve)
conj(armut, Elma)
~~~

~~~ sdparse
Geldiler ve film başladı . \n They arrived and the movie started.
cc(başladı, ve)
conj(başladı, Geldiler)
~~~

~~~ sdparse
Okudum ama hiçbirşey anlamadım . \n I read it but I did not understand anything
cc(anlamadım, ama)
conj(anlamadım, Okudum)
~~~

~~~ sdparse
Ali ile Ayşe'yi gördüm .  \n I saw Ali and Ayşe
conj(Ayşe'yi, Ali)
cc(Ayşe'yi, ile)
~~~
Note that in instrumental or commutative usage of _ile_ the relation [case]() is used.

~~~ sdparse
Ya Ayşe ya Ali oradadır . \n Either Ayşe or Ali would be there .
cc(Ali, ya-3)
cc(Ali, Ya-1)
conj(Ali, Ayşe)
~~~

~~~ sdparse
Ne Ayşe ne Ali geldi . \n Neither Ayşe nor Ali came .
cc(Ali, ne-3)
cc(Ali, Ne-1)
conj(Ali, Ayşe)
~~~

~~~ sdparse
Almak isterim de çok pahalı . \n I want to buy but it is too expensive
cc(pahalı, de)
conj(pahalı, isterim)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/cc.md" target="#">edit cc</a>
</div>

<div about="#ccomp_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#ccomp" />
	<a id="al-tr-dep/ccomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">ccomp</code>: <div property="rdfs:label">clausal complement</div></h2>
	<div property="rdfs:comment">

A clausal complement of a predicate is a dependent clause which is a core argument.
That is, it functions like an object of the predicate.

We split the verbal noun suffixes,
and mark them as the head of the subordinate clause.
The unit with the subordinating suffix is tagged as [noun](tr-pos/NOUN).
However, we still use `ccomp` for the relation between the higher level clause and the clausal object.

At present, we use `ccomp` only for direct objects, i.e., non-finite noun phrases in accusative or nominative [Case](tr-feat/Case).
The arguments in other cases are marked using [nmod]() relation or appropriate subtype of it.

~~~ sdparse
Sonunda " artık yeter " dedi . \n Finally, he said " that's enough " .
ccomp(dedi, yeter)
~~~

~~~ sdparse
Sevmiyorum demedim . \n I did not say I don't like it .
ccomp(demedim, Sevmiyorum)
~~~

~~~ sdparse
Sevme/VERB –diğimi/NOUN söylemedim/VERB . \n I did not that I don't like it .
ccomp(söylemedim, –diğimi)
acl(–diğimi, Sevme)
~~~

~~~ sdparse
Yarın gelecek sanıyordum . \n I thought he'd come tomorrow
ccomp(sanıyordum, gelecek)
~~~

~~~ sdparse
Sanıyordum ki yarın gelecek . \n I thought he'd come tomorrow
ccomp(Sanıyordum, gelecek)
mark(gelecek, ki)
~~~

~~~ sdparse
Yarın gelecek diye biliyordum . \n I knew (as if) she'd come tomorrow .
ccomp(biliyordum, gelecek)
makr(gelecek, diye)
~~~

See also [xcomp]().


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/ccomp.md" target="#">edit ccomp</a>
</div>

<div about="#ccomp%3Acau_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#ccomp" />
	<a id="al-tr-dep/ccomp:cau" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">ccomp:cau</code>: <div property="rdfs:label">clausal complement of a causative verb which refers to the "causee"</div></h2>
	<div property="rdfs:comment">

This is the clausal counterpart of [dobj:cau](dobj-cau).



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/ccomp-cau.md" target="#">edit ccomp:cau</a>
</div>

<div about="#compound_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#compound" />
	<a id="al-tr-dep/compound" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">compound</code>: <div property="rdfs:label">compound</div></h2>
	<div property="rdfs:comment">

`compound` is one of the relations in UD for compounding.
In Turkish it is used for bare noun compounds, compound verbal forms and numbers.

~~~ sdparse
Anneannem bana bir çift yün çorap örmüş . \n My grandmother knitted pair of woolen socks for me .
compound(çorap, yün)
~~~

~~~ sdparse
Yagmurlu havalardan nefret ediyor . \n He\/she hates rainy weather
compound(nefret, ediyor)
~~~

~~~ sdparse
Onun fiyatı iki yüz elli lira . \n Price of it is two hundred and fifty liras .
compound(iki, yüz)
conj:num(yüz, elli)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/compound.md" target="#">edit compound</a>
</div>

<div about="#compound%3Aredup_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#compound" />
	<a id="al-tr-dep/compound:redup" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">compound:redup</code>: <div property="rdfs:label">reduplicated compounds</div></h2>
	<div property="rdfs:comment">

This subtype of [compound]() covers a range of reduplicated forms in Turkish.
Reduplication is a common process especially for [adverbs](tr-pos/ADV) and [adjectives](tr-pos/ADJ),
but it is also used for reduplicated [noun](tr-pos/NOUN) and [verb](tr-pos/VERB) forms.

The reduplication typically involves two identical words,
but some morpho-phonological alternations (as in m-reduplication in example 3 below) are possible.
In some cases one of the words in reduplicated forms may also be modified individually by other words (see example 4 below).

~~~ sdparse
Koca koca adamlar oyun oynuyorlar . \n _Big (+emph)_ men are playing games .
compound:redup(koca-2, Koca-1)
~~~

~~~ sdparse
Açık açık söylüyorum . \n I am telling it _clearly_
compound:redup(açık-2, Açık-1)
~~~

~~~ sdparse
Araba maraba almışlar . \n They bought (a) car (and things like that)
compound:redup(Araba, maraba)
~~~

~~~ sdparse
Güzel mi güzel bir kız . \n A pretty (emphasized) girl .
compound:redup(güzel-3, Güzel)
advmod:emph(Güzel-1, mi)
~~~

~~~ sdparse
Herşeyi kendi kendilerine planlamışlar . \n They planed it all by themselves .
compound:redup(kendilerine, kendi)
~~~

~~~ sdparse
Ayağını sürükleye sürükleye yürüyordu . \n He\/she was walking by dragging his\/her feet.
compound:redup(sürükleye-3, sürükleye-2)
~~~

~~~ sdparse
Bu kadar zamanda okusa okusa birkaç sayfa okumuştur . \n In that time he\/she could have read _at most_ half of it .
compound:redup(okusa-5, okusa-4)
~~~

~~~ sdparse
Mektubu aldı alalı odasından çıkmadı . \n He\/she has not left his\/her room since he\/she got the letter
compound:redup(aldı, alalı)
~~~

~~~ sdparse
Mektubu alır almaz yanıt verdi . \n He\/she responded as soon as he\/she received the letter .
compound:redup(almaz, alır)
~~~

For lexicalized multi-word items with repetition where one or more of the words are not free lexemes, (e.g. _paldır küldür_, _ufak tefek_), we use [mwe]().


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/compound-redup.md" target="#">edit compound:redup</a>
</div>

<div about="#conj_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#conj" />
	<a id="al-tr-dep/conj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">conj</code>: <div property="rdfs:label">conjunct</div></h2>
	<div property="rdfs:comment">

A conjunct is the relation between two elements connected by a
coordinating conjunction, such as and, or, etc. 

We diverge from UD specification by marking the last (instead of the first) conjunct as the head of the relation.
All the other conjuncts depend on the last via the `conj` relation.

~~~ sdparse
Bir kız , iki erkek çocukları var . \n They have one girl and two boys.
conj(erkek, kız)
~~~

~~~ sdparse
Film siyah beyaz . \n The movie is black and white
conj(beyaz, siyah)
~~~

~~~ sdparse
Ayşe'yle Ali kavga ediyoralardı . \n Ayşe and Ali were fighting .
conj(Ali, Ayşe'yle)
~~~

~~~ sdparse
Ayşe , Ali ve beni davet etmedi . \n He\/she did not invite Ayşe , Ali and me .
conj(beni, Ali)
conj(beni, Ayşe)
cc(beni, ve)
punct(beni, ,-2)
~~~

~~~ sdparse
Ya Ayşe , ya Ali ya da  beni davet etmeliydi . \n He\/she should have invited not Ayşe , Ali or me .
conj(beni, Ali)
conj(beni, Ayşe)
cc(beni, ya-6)
cc(beni, ya-4)
cc(beni, Ya-1)
mwe(ya-6, da)
~~~

See the relation [cc]() for a few more examples.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/conj.md" target="#">edit conj</a>
</div>

<div about="#cop_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#cop" />
	<a id="al-tr-dep/cop" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cop</code>: <div property="rdfs:label">copula</div></h2>
	<div property="rdfs:comment">

A copula is the relation between a subject complement and a copular verb or copular suffix.
We always mark copula as dependent of the subject complement.

In Turkish, the auxiliary verb _ol-_ 
and in some constructions the negative particle _değil_ act like a free copula.
The main means of forming copular constructions, however, is through
the bound morpheme _-(y)_,
and (infrequently) its clitic form _i-_.
Since the morpheme _-(y)_ consists only of a "buffer" consonant,
in some morphological contexts, it is not realized.

Copular morphemes carry features, e.g., [Number](tr-feat/Number), [Person](tr-feat/Person),
that may conflict with the complement they are attached to.
Furthermore, the copular suffixes can also attach to verbal nouns,
causing conflicting dependency relations besides more feature conflicts.
As a result, all copular markers, 
including the "zero copula" are considered as a separate syntactic tokens.

~~~ sdparse
Güzel olacak . \n (He\/she\/it) will be beautiful
cop(Güzel, olacak)
~~~

~~~ sdparse
Güzel idi . (He\/she\/it) was beautiful
cop(Güzel, idi)
~~~

~~~ sdparse
Güzel –di . (He\/she\/it) was beautiful
cop(Güzel, –di)
~~~

~~~ sdparse
Güzel –im . \n I am beautiful
cop(Güzel, –im)
~~~

~~~ sdparse
Güzel –0 . \n He\/she\/it is beautiful (–0 represents the zero morpheme)
cop(Güzel, –0)
~~~

When an overt subject is present,
it is headed by the subject complement (not the copula).

~~~ sdparse
Kitap güzel –0 . \n The book is nice\/beautiful 
cop(güzel, –0)
nsubj(güzel, Kitap)
~~~

~~~ sdparse
Kitap güzel olacak . \n The book will be nice\/beautiful
cop(güzel, olacak)
nsubj(güzel, Kitap)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/cop.md" target="#">edit cop</a>
</div>

<div about="#csubj_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#csubj" />
	<a id="al-tr-dep/csubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubj</code>: <div property="rdfs:label">clausal subject</div></h2>
	<div property="rdfs:comment">

A clausal subject is a clausal syntactic subject of a clause, i.e., the subject is itself a clause.

~~~ sdparse
Kitabı oku –manız gerek . \n You need to read the book (You reading the book is necessary)
csubj(gerek, –manız)
~~~

~~~ sdparse
Kitabı oku –mak gerek . \n You need to read the book (Reading the book is necessary)
csubj(gerek, –mak)
~~~

TODO: link to the explanation of splitting of subordinating suffixes.

**The following needs more discussion**
We also analyze the nominal predicates with clausal subjects formed by subordinating conjunction _ki_ similarly.
In the METU-Sabancı treebank they are marked (somewhat inconsistently) as modifiers rather than main predicates.

~~~ sdparse
İyi ki okumuşsun . \n Good that you have read (that you read it is good)
csubj(İyi, okumuşsun)
~~~

~~~ sdparse
Tabii ki okudum . \n Of course I read it (that I read it is natural)
csubj(Tabii, okumuşsun)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/csubj.md" target="#">edit csubj</a>
</div>

<div about="#csubjpass_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#csubjpass" />
	<a id="al-tr-dep/csubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubjpass</code>: <div property="rdfs:label">clausal passive subject</div></h2>
	<div property="rdfs:comment">

A clausal passive subject is a clausal syntactic subject of a passive clause.

~~~ sdparse
Düya dönmüyor deniyordu . \n It was said "the earth is not rotating"
csubjpass(deniyordu, dönmüyor)
~~~

~~~ sdparse
Dünyanın dön –düğü biliniyor . \n (The fact that) the earth is rotating is known
csubjpass(biliniyor, –düğü)
~~~

~~~ sdparse
Biliniyor ki dünya dönüyor . \n It is known that the earth is rotating
csubjpass(Biliniyor, dönüyor)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/csubjpass.md" target="#">edit csubjpass</a>
</div>

<div about="#dep_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#dep" />
	<a id="al-tr-dep/dep" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dep</code>: <div property="rdfs:label">unspecified dependency</div></h2>
	<div property="rdfs:comment">

A dependency is labeled as `dep` when a system is unable to determine a more precise dependency relation between two words.

We currently do not use the `dep` label.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/dep.md" target="#">edit dep</a>
</div>

<div about="#det_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#det" />
	<a id="al-tr-dep/det" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">det</code>: <div property="rdfs:label">determiner</div></h2>
	<div property="rdfs:comment">

The relation determiner (det) holds between a nominal head and its determiner.

~~~ sdparse
Bütün kitapları okudu . \n (He\/she) have read all books
det(kitapları, Bütün)
~~~

~~~ sdparse
Güzel bir kitap okudum . \n I read a nice book
det(kitap, bir)
amod(kitap, Güzel)
~~~

~~~ sdparse
Bu kitabı okumalısın . \n You should read this book
det(kitabı, Bu)
~~~

~~~ sdparse
Bazı kitaplar bombadan tehlikelidir . \n Some books are more dangerous than a bomb
det(kitaplar, Bazı)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/det.md" target="#">edit det</a>
</div>

<div about="#discourse_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#discourse" />
	<a id="al-tr-dep/discourse" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">discourse</code>: <div property="rdfs:label">discourse element</div></h2>
	<div property="rdfs:comment">

This is used for interjections and other discourse particles and elements
(which are not clearly linked to the structure of the sentence, except in an expressive way).

~~~ sdparse
Okudu mu acaba ? \n Did he\/she read (I wonder) ?
discourse(Okudu, acaba)
~~~

~~~ sdparse
Çabuk okusa bari . \n I wish he reads quickly 'bari'
discourse(okusa, bari)
~~~

~~~ sdparse
Aferin , okumuşsun . \n Well done! You must have read it.
discourse(okumuşsun, Aferin)
~~~

~~~ sdparse
Bak , bu kitabı okumalısın . \n look, you need to read this book
discourse(okumalısın, Bak)
~~~

~~~ sdparse
Peki , kitabı okudun mu ? \n OK, have you read the book?
discourse(okudun, Peki)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/discourse.md" target="#">edit discourse</a>
</div>

<div about="#dislocated_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#dislocated" />
	<a id="al-tr-dep/dislocated" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dislocated</code>: <div property="rdfs:label">dislocated elements</div></h2>
	<div property="rdfs:comment">

The `dislocated` relation is used for fronted or postposed elements that do not fulfill the usual core grammatical relations of a sentence.
These elements often appear to be in the periphery of the sentence,
and may be separated off with a comma intonation.

~~~ sdparse
Ali ki hızlı okur, o bile kitabı bitiremedi . \n Ali, who is a fast reader, even he could not finish the book .
dislocated(o, Ali)
~~~

~~~ sdparse
Bir öğrenci ki yazım kurallarına dikkat etmez, ben onu dersten geçirmem . \n A student who does not pay attention to the spelling, I do not allow him/her to pass the course .
dislocated(onu, öğrenci)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/dislocated.md" target="#">edit dislocated</a>
</div>

<div about="#dobj_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#dobj" />
	<a id="al-tr-dep/dobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dobj</code>: <div property="rdfs:label">direct object</div></h2>
	<div property="rdfs:comment">

The direct object of a verb is the noun phrase that denotes the entity acted upon.

In Turkish, direct objects take either nominative (unmarked), or accusative [cases](tr-feat/Case).
We do not mark arguments of verbs in other cases with `dobj`.
(**NOTE:** Kyrgiz treebank marks ablatives as in _pastadan aldı_ 'he took from the cake'. We may consider doing the same. At least we should try to unify the analyses.)
Note also that we mark objects of intransitive causative verbs using [dobj:cau](dobj-cau).

~~~ sdparse
Hafta sonları kitap okurum . \n I read (books) during weekends
dobj(okurum, kitap)
~~~

~~~ sdparse
Kitabı okudum . \n I read the book.
dobj(okudum, Kitabı)
~~~

We also mark the non-case marked or accusative noun phrases as `dobj` even if they are not the entities that are acted upon.

~~~ sdparse
Dün 10 kilometre koştum . \n I ran 10 kilometers yesterday
dobj(koştum, kilometre)
~~~

~~~ sdparse
Dün 10 kilometreyi 35 dakikada koştum . \n  Yesterday, I ran 10 kilometers in 35 minutes
dobj(koştum, kilometreyi)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/dobj.md" target="#">edit dobj</a>
</div>

<div about="#dobj%3Acau_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#dobj" />
	<a id="al-tr-dep/dobj:cau" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dobj:cau</code>: <div property="rdfs:label">direct object of an intransitive causative verb</div></h2>
	<div property="rdfs:comment">

This is a subtype of [dobj]().
We mark direct objects of causative [voice](tr-dep/Voice) intransitive verbs with this subtype,
since the interpretation is different in comparison to a direct object of a non-causative verb.
In general, if the verb is intransitive, direct object indicates the "causee",
the subject of the content verb, or the entity that performs the action.
If the verb is transitive the direct object is the entity that is acted upon as in the non-causative case (see [nmod:cau](nmod-cau)).

~~~ sdparse
Annesi bebeği giydirdi . \n His mother dressed (caused to dress) the baby
dobj:cau(giydirdi, bebeği)
~~~

~~~ sdparse
Bebek herkesi sevindirdi . \n The baby causes everyone to be happy
dobj:cau(sevindirdi, herkesi)
~~~ 

~~~ sdparse
Öğretmen dersi kolaylaştırdı . \n The teacher made the course easier
dobj:cau(kolaylaştırdı, dersi)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/dobj-cau.md" target="#">edit dobj:cau</a>
</div>

<div about="#expl_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#expl" />
	<a id="al-tr-dep/expl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">expl</code>: <div property="rdfs:label">expletive</div></h2>
	<div property="rdfs:comment">

Turkish does not have expletives.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/expl.md" target="#">edit expl</a>
</div>

<div about="#foreign_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#foreign" />
	<a id="al-tr-dep/foreign" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">foreign</code>: <div property="rdfs:label">foreign words</div></h2>
	<div property="rdfs:comment">

We use foreign to label sequences of foreign words.
These are given a linear analysis: the head is the first token in the foreign phrase.

~~~ sdparse
Diplomat ve uzmanlarla off the record görüşmeler yaptım . \n I had off the record interviews with diplomats and experts .
amod(görüşmeler, off)
foreign(off, the)
foreign(off, record)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/foreign.md" target="#">edit foreign</a>
</div>

<div about="#goeswith_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#goeswith" />
	<a id="al-tr-dep/goeswith" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">goeswith</code>: <div property="rdfs:label">goes with</div></h2>
	<div property="rdfs:comment">

This relation links two parts of a word that are separated in text that is not well edited. 
The head is in some sense the "main" part, often the second part.

~~~ sdparse
Bu kitap hiç bir işe yaramaz . \n This book is worth nothing.
goeswith(bir, hiç)
det(bir)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/goeswith.md" target="#">edit goeswith</a>
</div>

<div about="#iobj_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#iobj" />
	<a id="al-tr-dep/iobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">iobj</code>: <div property="rdfs:label">indirect object</div></h2>
	<div property="rdfs:comment">

We do not use the dependency label `iobj`.

TODO: link to argument/adjunct discussion.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/iobj.md" target="#">edit iobj</a>
</div>

<div about="#list_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#list" />
	<a id="al-tr-dep/list" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">list</code>: <div property="rdfs:label">list</div></h2>
	<div property="rdfs:comment">

The `list` relation is used for chains of comparable items. In lists with more than two items, all items of the list should modify the first one. Informal and web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences. Email signatures often contain these structures, in the form of contact information: the different contact information items are labeled as `list`; the key-value pair relations are labeled as [appos]().


~~~ sdparse
Ali Yılmaz ,  tel : 555-55-55 , email : ali@example.com
name(Ali, Yılmaz)
list(Ali, tel)
list(Ali, email)
appos(tel, 555-55-55)
appos(email, ali@example.com)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/list.md" target="#">edit list</a>
</div>

<div about="#mark_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#mark" />
	<a id="al-tr-dep/mark" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mark</code>: <div property="rdfs:label">marker</div></h2>
	<div property="rdfs:comment">

A marker is the subordinating conjunction introducing a finite clause subordinate to another clause.
The mark is a dependent of the subordinate clause head.

~~~ sdparse
Okusun diye kitaplar aldım . \n I bought books for him to read .
mark(Okusun, diye)
~~~

~~~ sdparse
Okudum ki öğreneyim . \n I read in order to learn.
mark(öğreneyim, ki)
~~~

~~~ sdparse
Göründüğü kadar güzel mi ? \n Is it as good as it looks?
mark(Göründüğü, kadar)
~~~

~~~ sdparse
Başladın mı ,  gerisi gelir. \n Once you start, the rest would follow
mark(Başladın, mı)
~~~

~~~ sdparse
Okudum da anladım . \n I understood by reading
mark(Okudum, da)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/mark.md" target="#">edit mark</a>
</div>

<div about="#mwe_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#mwe" />
	<a id="al-tr-dep/mwe" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mwe</code>: <div property="rdfs:label">multi-word expression</div></h2>
	<div property="rdfs:comment">

The multi-word expression (modifier) relation is one of the three relations ([compound](), `mwe`, [name]()) for compounding.
It is used for certain fixed grammaticized expressions that behave like function words or short adverbials.

Note that, we mark most of the expressions that are marked `MWE` in METU-Sabancı treebank as `compound`. 
`mwe` is only used for fixed expressions that do not show any morphological variation.

~~~ sdparse
Ali ya da Ahmet  \n Ali or Ahmet
mwe(ya, da)
~~~

~~~ sdparse
Bir tek Ali okumamış . \n Only Ali did not read
mwe(bir, tek)
~~~

~~~ sdparse
Her ne kadar aradıysam da ulaşamadım . \n Despite calling many times, I could not reach (him\/her)
mwe(Her, ne)
mwe(Her, kadar)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/mwe.md" target="#">edit mwe</a>
</div>

<div about="#name_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#name" />
	<a id="al-tr-dep/name" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">name</code>: <div property="rdfs:label">name</div></h2>
	<div property="rdfs:comment">

`name` is one of the three relations for compounding in UD (together with [compound]() and [mwe]()).
It is used for proper nouns constituted of multiple nominal elements.
For phrasal or clausal names the usual relations are used.

~~~ sdparse
Mustafa Kemal
name(Kemal, Mustafa)
~~~

~~~ sdparse
Mustafa Kemal Paşa
name(Kemal, Mustafa)
nmod(Paşa, Kemal)
~~~

~~~ sdparse
Necla Hanım
nmod(Hanım, Necla)
~~~

~~~ sdparse
Mahmut öğretmen
nmod(öğretmen, Mahmut)
~~~

~~~ sdparse
Türkiye Büyük Millet Meclisi
nmod:poss(Meclisi, Millet)
amod(Meclisi, Büyük)
nmod:poss(Meclisi, Türkiye)
~~~

~~~ sdparse
Van Gölü
nmod:poss(Gölü, Van)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/name.md" target="#">edit name</a>
</div>

<div about="#neg_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#neg" />
	<a id="al-tr-dep/neg" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">neg</code>: <div property="rdfs:label">negation modifier</div></h2>
	<div property="rdfs:comment">

The negation modifier is the relation between a negation word and the word it modifies.

In Turkish, negation is typically done through suffixation.
We use `neg` only if the non-predicative use of  the word _değil_.

~~~ sdparse
Elma değil , armut al demiştim . \n I asked for pears, not for apples.
neg(Elma, değil)
~~~

~~~ sdparse
En büyüğünü al dedim, küçük değil . \n I told you to get the biggest
not small(est)
neg(küçük, değil)
~~~


~~~ sdparse
Değil üniversite , orta okulu bile bitirmemiş . \n Let alone the university, he did not even finish the secondary school
neg(üniversite, Değil)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/neg.md" target="#">edit neg</a>
</div>

<div about="#nmod_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod</code>: <div property="rdfs:label">nominal modifier</div></h2>
	<div property="rdfs:comment">

The `nmod` relation is used for nominal modifiers.
They depend either on another noun (group “noun dependents”) or on a predicate (group “non-core dependents of clausal predicates”).

`nmod` is a [noun](tr-pos/NOUN) (or noun phrase) functioning as a non-core (oblique) argument or adjunct.
This means that it functionally corresponds to an adverbial when it attaches to a verb, adjective or other adverb.
But when attaching to a noun, it corresponds to an attribute, or genitive complement (the terms are less standardized here).

The `nmod` relation is further specified by the [Case](tr-feat/Case) feature or [case]() relation.

We also use the following language-specific subtypes for nmod:

- [nomd:cau](nmod-cau): nominal modifier of a causative predicate that
  markes the _causee_.
- [nmod:comp](nmod-comp): a comparative nominal modifier
- [nmod:pass](nmod-pass): nominal modifier of a passive predicate that
  express the actor (subject of the active predicate)
- [nmod:tmod](nmod-tmod): nominal modifier that indicates time
- [nmod:own](nmod-own): owner in a possessive existential sentence
- [nmod:poss](nmod-poss): possessor in in a genitive-possessive construction
- [nmod:part](nmod-part): noun modifier specifying the whole-part relation

We do not currently distinguish between core arguments and adjuncts
(TODO: link to discussion).

~~~ conllu
# I read the book on the plane
1	Kitabı	kitap	NOUN	NOUN	Case=Acc	3	dobj
2	uçakta	uçak	NOUN	NOUN	Case=Loc	3	nmod
3	okudum	oku	VERB	VERB	Tense=Past|Person=1|Number=Sing	0	root
~~~

~~~ conllu
# I read the book with the glasses
1	Kitabı	kitap	NOUN	NOUN	Case=Acc	3	dobj
2	gözlükle	gözlük	NOUN	NOUN	Case=Ins	3	nmod
3	okudum	oku	VERB	VERB	Tense=Past|Person=1|Number=Sing	0	root
~~~

~~~ conllu
# I read the book out of curiosity
1	Kitabı	kitap	NOUN	NOUN	Case=Acc	3	dobj
2	meraktan	merak	NOUN	NOUN	Case=Abl	3	nmod
3	okudum	oku	VERB	VERB	Tense=Past|Person=1|Number=Sing	0	root
~~~

~~~ conllu
# I read the book to the children
1	Kitabı	kitap	NOUN	NOUN	Case=Acc	3	dobj
2	çocuklara	çocuk	NOUN	NOUN	Case=Dat	3	nmod
3	okudum	oku	VERB	VERB	Tense=Past|Person=1|Number=Sing	0	root
~~~

~~~ sdparse
resim –li kitap \n (the\/a) book with illustrations
nmod(kitap, resim)
case(resim, –li)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod.md" target="#">edit nmod</a>
</div>

<div about="#nmod%3Acau_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod:cau" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:cau</code>: <div property="rdfs:label">nominal modifier indicating the causee of a causative predicate</div></h2>
	<div property="rdfs:comment">

This subtype of [nmod]() is used for marking the performer of the real action, "causee", in a causative predicate.
The subject of the causative predicate is the actor who _causes_ the action to be taken.
Occasionally the performer of the action is also included in the phrase/sentence, and it is useful to mark it.
The causee is predictable for intransitive verbs,
since it is the object of the causative predicate.
For transitive verbs, it is often marked with dative [Case](tr-feat/Case),
but it is ambiguous as a dative nominal modifier also has the function of marking the "beneficiary" (and possibly others).


~~~ sdparse
Annesi bebeği uyuttu . \n Her mother caused the baby to sleep (=put the baby to sleep)
nmod:cau(uyuttu, bebeği)
nsubj(uyuttu, Annesi)
~~~

~~~ sdparse
Öğretmen kitabı Ali'ye okuttu . \n The teacher caused (made) Ali to read the book
nmod:cau(okuttu, Ali'ye)
nsubj(okuttu, Öğretmen)
~~~
Note that the above is ambiguous.
It may also mean "The teacher made someone to read the book to/for Ali".
In that case [nmod]() should be used.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod-cau.md" target="#">edit nmod:cau</a>
</div>

<div about="#nmod%3Acomp_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod:comp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:comp</code>: <div property="rdfs:label">comparative modifier of an adjective or adverb</div></h2>
	<div property="rdfs:comment">

This subtype of [nmod]() is used for marking comparative modifier of an [adjective](tr-pos/Adj) or [adverb](tr-pos/Adv).


~~~ sdparse
Türkiye'den sıcak bir ülke \n A country warmer than Turkey
nmod:comp(sıcak, Türkiye'den)
~~~

~~~ sdparse
Benden çok okudu . \n He\/she read more than me (more than I did)
nmod:comp(çok, Benden)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod-comp.md" target="#">edit nmod:comp</a>
</div>

<div about="#nmod%3Aown_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod:own" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:own</code>: <div property="rdfs:label">owner in a possessive existential sentence</div></h2>
	<div property="rdfs:comment">

**This needs more discussion**

This subtype of [nmod]() is used for marking the owner of a possessive existential sentence.

In Turkish possessive sentences (e.g., "I have a book") resemble existential sentences
where the subject is the entity that "exists", or "owned".
`nmod:own` relation marks the entity that "owns" the subject.
The head of the relation is the predicate,
as opposed to the subject noun phrase
(this allows a uniform analysis in case the subject is dropped).
It should not be confused with [nmod:poss](nmod-poss),
which is used in (genitive-)possessive constructions.

~~~ sdparse
Benim bir kitabım var . \n I have a book
nmod:own(var, Benim)
nsubj(var, kitabım)
~~~

~~~ sdparse
Benim var , ama Ali'nin yok . \n I have (it\/something), but Ali doesn't
nmod:own(var, Benim)
nmod:own(yok, Ali'nin)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod-own.md" target="#">edit nmod:own</a>
</div>

<div about="#nmod%3Apart_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod:part" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:part</code>: <div property="rdfs:label">nominal modifier indicating part-whole relations</div></h2>
	<div property="rdfs:comment">

This subtype of [nmod]() is used for marking the part-whole relations.
The structure is similar to [nmod:poss](nmod-poss) in most cases,
but the range structures expressing "part of" is diverse, 
and distinction is often be useful.

~~~ sdparse
Kitapların üçü \n three of the books
nmod:part(üçü, Kitapların)
~~~

~~~ sdparse
Kitapların hepsi \n All of the books
nmod:part(hepsi, Kitapların)
~~~

~~~ sdparse
Sevidiğim kitaplardan biri \n One of the books I like
nmod:part(biri, kitaplardan)
~~~

~~~ sdparse
Şu elmalardan bir kilo  \n A kilo of\/from those apples
nmod:part(kilo, elmalardan)
~~~

~~~ sdparse
Öğrencilerden bir kız \n A girl from\/among the students 
nmod:part(kız, Öğrencilerden)
~~~

~~~ sdparse
Öğrenciler arasından bir kız \n A girl from\/among the students 
nmod:part(kız, Öğrenciler)
case(Öğrenciler, arasından)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod-part.md" target="#">edit nmod:part</a>
</div>

<div about="#nmod%3Apass_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod:pass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:pass</code>: <div property="rdfs:label">nominal modifier indicating the actor of a passive predicate</div></h2>
	<div property="rdfs:comment">

This subtype of [nmod]() is used for marking the performer of action (the subject in the corresponding active sentence) in a passive predicate.


~~~ sdparse
Kitap öğrenciler tarafından okundu . \n The book was read by the students
nmod:pass(okundu, öğrenciler)
case(öğrenciler, tarafından)
nsubjpass(okundu, Kitap)
~~~

~~~ sdparse
Kitap öğrenciler –ce okundu . \n The book was read by the students
nmod:pass(okundu, öğrenciler)
case(öğrenciler, –ce)
nsubjpass(okundu, Kitap)
~~~

~~~ sdparse
Araba aşırı sıcaktan bozulmuş . \n The car was broken by extreme heat
nmod:pass(bozulmuş, sıcaktan)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod-pass.md" target="#">edit nmod:pass</a>
</div>

<div about="#nmod%3Aposs_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod:poss" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:poss</code>: <div property="rdfs:label">possessive nominal modifier</div></h2>
	<div property="rdfs:comment">

This subtype of [nmod]() is used in (genitive-)possessive constructions.
Typically, the head of the construction is a possessive noun phrase,
and the dependent is in genitive [case](tr-feat/Case).
We also use `nmod:poss` in the alternative construction where the modifier is not in genitive case.
So-called "bare noun compounds" are marked using the [compound]() relation.

~~~ sdparse
Ali'nin kitabı   \n Ali's book
nmod:poss(kitabı, Ali'nin)
~~~

~~~ sdparse
Sabah kahvesi \n Morning coffee
nmod:pos(kahvesi, Sabah)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod-poss.md" target="#">edit nmod:poss</a>
</div>

<div about="#nmod%3Atmod_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-tr-dep/nmod:tmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:tmod</code>: <div property="rdfs:label">temporal modifier</div></h2>
	<div property="rdfs:comment">

A temporal modifier is a subtype of the [nmod]() relation: if the modifier is specifying time, it is labeled as `nmod:tmod`.

~~~ sdparse
Geçen hafta bir kitap okudum . \n Las week I read a book
nmod:tmod(okudum, hafta)
~~~

~~~ sdparse
Üç ay –dır okumuyorum . \n I haven't been reading for three months
case(ay, –dır)
nmod:tmod(okumuyorum, ay)
~~~

~~~ sdparse
Öğleden sonra okuyacağım . \n I will read (it) in the afternoon
case(Öğleden, sonra)
nmod:tmod(okuyacağım, Öğleden)
~~~

~~~ sdparse
Her yıl aynı yere gidiyoruz . \n We go to the same place every year
nmod:tmod(gidiyoruz, yıl)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nmod-tmod.md" target="#">edit nmod:tmod</a>
</div>

<div about="#nsubj_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubj" />
	<a id="al-tr-dep/nsubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubj</code>: <div property="rdfs:label">nominal subject</div></h2>
	<div property="rdfs:comment">

A nominal subject is a noun phrase which is the syntactic subject of a clause. 

~~~ sdparse
Ali okuyor . \n Ali is reading
nsubj(okuyor, Ali)
~~~

For existential sentences, "the thing that exists" is the subject.
This includes possessive existentials.

~~~ sdparse
Üç kitap var . \n There are three books
nsubj(var, kitap)
~~~

~~~ sdparse
Benim üç kitabım var . \n I have three books
nsubj(var, kitabım)
~~~

Although we currently mark the head of the verbal nouns as nouns,
we use [csubj]() when they are in the subject position.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nsubj.md" target="#">edit nsubj</a>
</div>

<div about="#nsubjpass_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubjpass" />
	<a id="al-tr-dep/nsubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubjpass</code>: <div property="rdfs:label">passive nominal subject</div></h2>
	<div property="rdfs:comment">

A passive nominal subject is a noun phrase which is the syntactic subject of a passive clause.

The distinction between [nsubj]() and `nsubjpass` is not strictly necessary in Turkish,
since the predicate will always be morphologically marked as passive.

~~~ sdparse
Kitap okundu . \n The book was read
nsubjpass(okundu, Kitap)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nsubjpass.md" target="#">edit nsubjpass</a>
</div>

<div about="#nummod_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#nummod" />
	<a id="al-tr-dep/nummod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nummod</code>: <div property="rdfs:label">numeric modifier</div></h2>
	<div property="rdfs:comment">

A numeric modifier of a noun is any number phrase that serves to modify the meaning of the noun with a quantity.

~~~ sdparse
Üç kitap aldım \n I bought three books
nummod(kitap, Üç)
~~~

~~~ sdparse
Üçüncü kitabı da bitirdim . \n I finished third book as well
nummod(kitap, Üçüncü)
~~~

~~~ sdparse
Üçer kitap aldık . \n We boot three books each
nummod(kitap, Üçer)
~~~

~~~ sdparse
1500 lira harcadı \n He\/she spent 1500 liras
nummod(lira, 1500)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/nummod.md" target="#">edit nummod</a>
</div>

<div about="#parataxis_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#parataxis" />
	<a id="al-tr-dep/parataxis" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">parataxis</code>: <div property="rdfs:label">parataxis</div></h2>
	<div property="rdfs:comment">

The parataxis relation (from Greek for “place side by side”) is a relation between the main verb of a clause and other sentential elements, 
such as a sentential parenthetical, a clause after a “:” or a “;”, 
or two sentences placed side by side without any explicit coordination or subordination.

~~~ sdparse
Kitabı okudum , uyudum . \n I read the book , slept.
parataxis(uyudum, okudum)
~~~

~~~ sdparse
Kitabı okudun , değil mi ? \n You read the book , aren't you ?
parataxis(okudun, değil)
~~~

~~~ sdparse
Sabah , babam diyor ki , erken kalkacakmışız . \n In the morning, my father says, we have to get up early
parataxis(kalkacakmışız, diyor)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/parataxis.md" target="#">edit parataxis</a>
</div>

<div about="#punct_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#punct" />
	<a id="al-tr-dep/punct" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">punct</code>: <div property="rdfs:label">punctuation</div></h2>
	<div property="rdfs:comment">

This is used for any piece of punctuation in a clause. See
[u-dep/punct]() for details.

~~~ sdparse
Kitabı okudum . \n I read the book
punct(okudum, .)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/punct.md" target="#">edit punct</a>
</div>

<div about="#remnant_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#remnant" />
	<a id="al-tr-dep/remnant" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">remnant</code>: <div property="rdfs:label">remnant in ellipsis</div></h2>
	<div property="rdfs:comment">

The remnant relation is used to provide a satisfactory treatment of certain instances of ellipsis.

~~~ sdparse
Ali kitabı okudu , Ahmet de . \n Ali read the book, Ahmet too.
nsubj(okudu, Ali)
remnant(Ali, Ahmet)
~~~

~~~ sdparse
Ali okudu kitabı , Ahmet değil . \n Ali read the book, not Ahmet.
nsubj(okudu, Ali)
remnant(Ali, Ahmet)
~~~

~~~ sdparse
Ali kitap , Ahmet gazete okudu . \n Mehmet read newspapers, Ahmet books.
nsubj(okudu, Ahmet)
dobj(okudu, gazete)
remnant(Ahmet, Ali)
remnant(gazete, kitap)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/remnant.md" target="#">edit remnant</a>
</div>

<div about="#reparandum_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#reparandum" />
	<a id="al-tr-dep/reparandum" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">reparandum</code>: <div property="rdfs:label">overridden disfluency</div></h2>
	<div property="rdfs:comment">

We use `reparandum` to indicate disfluencies overridden in a speech repair.
The disfluency is the dependent of the repair.

~~~ sdparse
Sağa– sola dön . \n Turn right- left .
nmod(dön, sola)
reparandum(sola, Sağa–)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/reparandum.md" target="#">edit reparandum</a>
</div>

<div about="#root_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#root" />
	<a id="al-tr-dep/root" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">root</code>: <div property="rdfs:label">root</div></h2>
	<div property="rdfs:comment">

The `root` grammatical relation points to the root of the sentence.
A fake node "ROOT" is used as the governor.
The ROOT node is indexed with "0", since the indexation of real words in the sentence starts at 1.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/root.md" target="#">edit root</a>
</div>

<div about="#vocative_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#vocative" />
	<a id="al-tr-dep/vocative" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">vocative</code>: <div property="rdfs:label">vocative</div></h2>
	<div property="rdfs:comment">

The vocative relation is used to mark dialogue participant addressed in text.
The relation links the addressee’s name to its host sentence.

~~~ sdparse
Ali , gel . \n Ali, come here!
vocative(gel, Ali)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/vocative.md" target="#">edit vocative</a>
</div>

<div about="#xcomp_tr" property="rdf:type" resource="#dep_tr">
	<div property="rdf:type" resource="../../u/dep/all.html#xcomp" />
	<a id="al-tr-dep/xcomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">xcomp</code>: <div property="rdfs:label">open clausal complement</div></h2>
	<div property="rdfs:comment">

An open clausal complement of a predicate is a predicative or clausal complement without its own subject.
The reference of the subject is necessarily determined by an argument external to the xcomp (normally by the object of the next higher clause, if there is one, or else by the subject of the next higher clause.
These complements are always non-finite, and they are complements (arguments of the higher predicate) rather than adjuncts/modifiers, such as a purpose clause.

In majority of the cases, we use `xcomp` for the verbal nouns formed by the suffix _-mAk_.
Note that we split the nominal part, and mark the noun as the head of the predicate.
(TODO: link to the subordination discussion)

~~~ sdparse
Oku/VERB –mak/NOUN istiyor/VERB . \n He wants to read
xcomp(istiyor, –mak)
acl(–mak, Oku)
~~~

In addition, we also use `xcomp` for secondary predicates, 
or in general, what Göksel &amp; Kerslake (2005) calls "small clauses".
The decision between a secondary predicate or adverb analysis is often diffcult,
since most adjectives also function as adverbs.

~~~ sdparse
Ali çayını soğuk içer . \n Ali drinks his tea cold
xcomp(içer, soğuk)
~~~

~~~ sdparse
Bu kitap bir baş yapıt sayılır . \n This book is considered a master piece
xcomp(sayılır, yapıt)
~~~

~~~ sdparse
Onu İstanbul'da sanıyordum . \n I tought he\/she was in Istanbul
xcomp(sanıyordum, İstanbul'da)
~~~

### References
Aslı Göksel and Celia Kerslake. _Turkish: A Comprehensive Grammar_.
London: Routledge, 2005.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_tr-dep/xcomp.md" target="#">edit xcomp</a>
</div>


      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html
	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'tr-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
