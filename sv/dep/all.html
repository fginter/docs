<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml"
	prefix:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
	prefix:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
	prefix:oliasystem="http://purl.org/olia/system.owl#"
	prefix:xsd="http://www.w3.org/2001/XMLSchema#"
>

  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Dependencies</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
	
          <span class="header-text"><a href="http://universaldependencies.org/#language-sv">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          
<h1 id="dependencies">Dependencies</h1>

<p><span about="." property="rdf:type" resource="owl:Ontology">
	<span property="owl:imports" resource=" https://www.w3.org/2012/pyRdfa/extract?uri=http://universaldependencies.org/docs/u/dep/all.html&amp;format=xml&amp;rdfagraph=output&amp;vocab_expansion=false&amp;rdfa_lite=false&amp;embedded_rdf=true&amp;space_preserve=false&amp;vocab_cache=true&amp;vocab_cache_report=false&amp;vocab_cache_refresh=false"></span>
</span></p>

<p>Note: <i>nmod</i>, <i>neg</i>, and <i>punct</i> appear
in two places.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a>nsubj</a></td>
	  <td><a>csubj</a></td>
	</tr>
	<tr>
	  <td><a>nsubjpass</a></td>
	  <td><a>csubjpass</a></td>
	</tr>
	<tr>
	  <td><a>dobj</a></td>
	  <td><a>ccomp</a></td>
	  <td><a>xcomp</a></td>
	</tr>
	<tr>
	  <td><a>iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Non-core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td><a>advcl</a></td>
	  <td><a>advmod</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:agent</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:poss</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Special clausal dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a>vocative</a></td>
	  <td><a>aux</a></td>
	  <td><a>mark</a></td>
	</tr>
	<tr>
	  <td><a>discourse</a></td>
	  <td><a>auxpass</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>expl</a></td>
	  <td><a>cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Noun dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nummod</a></td>
	  <td><a>acl</a></td>
	  <td><a>amod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>↳<a>acl:relcl</a></td>
	</tr>
	<tr>
	  <td><a>appos</a></td>
	  <td>&nbsp;</td>
	  <td><a>det</a></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Compounding and unanalyzed</strong></td></tr>
	<tr>
	  <td><a>compound</a></td>
	  <td><a>mwe</a></td>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td>↳<a>compound:prt</a></td>
	</tr>
	<tr>
	  <td><a>name</a></td>
	  <td><a>foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Coordination</strong></td></tr>
	<tr>
	  <td><a>conj</a></td>
	  <td><a>cc</a></td>
	  <td><a>punct</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Case-marking, prepositions, possessive</strong></td></tr>
	<tr>
	  <td><a>case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Loose joining relations</strong></td></tr>
	<tr>
	  <td><a>list</a></td>
	  <td><a>parataxis</a></td>
	  <td><a>remnant</a></td>
	</tr>
	<tr>
	  <td><a>dislocated</a></td>
	  <td></td><td><a>reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Other</strong></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<p><span about="#dep_sv" property="rdfs:label" style="visibility: hidden">Dependencies</span>
<span about="#dep_sv" property="rdfs:subClassOf" resource="_:sv">
	<span about="_:sv" property="rdf:type" resource="owl:Restriction">
		<span property="owl:onProperty" resource="http://purl.org/dc/terms/language"></span>
		<span property="owl:hasValue" lang="" style="visibility: hidden">sv</span>
	</span>
</span></p>

<hr />

<div about="#acl_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#acl" />
	<a id="al-sv-dep/acl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">acl</code>: <div property="rdfs:label">clausal modifier of noun</div></h2>
	<div property="rdfs:comment">

`acl` is used for finite and non-finite clauses that modify a noun, including cases of secondary predication. 
Note that in Swedish relative clauses get assigned a specific relation [acl:relcl](), a subtype of `acl`.

Non-relative clausal dependents of nouns are limited to complement clauses with a subset of nouns like *faktum (fact)*.  We analyze them as `acl` (parallel to the analysis of this class as "content clauses" in Huddleston and Pullum 2002). Such clausal complements are usually finite (though there are occasional remnant Swedish subjunctives). 

~~~ sdparse
Hur förenas detta med det faktum att många äktenskap upplöses ? \n How can that be reconciled with the fact that many marriages break up?
acl(faktum, upplöses) 
~~~

In addition, interrogative clauses can be linked to nouns by prepositions.

~~~ sdparse
En bild av vad som händer \n A picture of what happens
acl(bild, händer)
~~~

~~~ sdparse
Ta ansvar för vad du gör \n Take responsibility for what you do
acl(ansvar, gör)
~~~

The `acl` relation is also used for secondary predicates modifying a nominal.

~~~ sdparse
Han lämnade rummet gråtande . \n He left the room crying .
acl(Han, gråtande)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/acl.md" target="#">edit acl</a>
</div>

<div about="#acl%3Arelcl_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#acl" />
	<a id="al-sv-dep/acl:relcl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">acl:relcl</code>: <div property="rdfs:label">relative clause modifier</div></h2>
	<div property="rdfs:comment">

The `acl:relcl` relation is used for relative clauses modifying
a nominal. The relation points from the head of the nominal to the
head of the relative clause. Relative clauses are always finite in Swedish
and the relative pronoun can be omitted when it does not have the subject function.

~~~ sdparse
Jag såg den man som älskar dig \n I saw the man who loves you
acl:relcl(man-4, älskar)
nsubj(älskar, som)
dobj(älskar, dig)
~~~
~~~ sdparse
Jag såg den man som du älskar \n I saw the man who you love
acl:relcl(man-4, älskar)
nsubj(älskar, du)
dobj(älskar, som)
~~~

~~~ sdparse
Jag såg den man du älskar \n I saw the man you love
acl:relcl(man-4, älskar)
nsubj(älskar, du)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/acl-relcl.md" target="#">edit acl:relcl</a>
</div>

<div about="#advcl_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#advcl" />
	<a id="al-sv-dep/advcl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advcl</code>: <div property="rdfs:label">adverbial clause modifier</div></h2>
	<div property="rdfs:comment">

An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.) as a modifier, not as a core complement. This includes things like temporal, conditional and purpose clauses, etc. The dependent must be clausal (or else it is an [advmod]()) and the dependent is the main predicate of the clause.

~~~ sdparse
Han gör inte ett dugg hemma när han kommer hem \n He doesn't do anything around the house when he gets home
advcl(gör, kommer)
~~~

~~~ sdparse
Jag måste arbeta för att ekonomin ska gå ihop \n I have to work to make ends meet
advcl(arbeta, gå)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/advcl.md" target="#">edit advcl</a>
</div>

<div about="#advmod_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#advmod" />
	<a id="al-sv-dep/advmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advmod</code>: <div property="rdfs:label">adverbial modifier</div></h2>
	<div property="rdfs:comment">

An adverbial modifier of a word is a (non-clausal) adverb or adverbial
phrase that serves to modify the meaning of the word.

~~~ sdparse
Det bör kraftigt understrykas \n It should be strongly emphasised
advmod(understrykas, kraftigt)
~~~

~~~ sdparse
mindre ofta \n less often
advmod(ofta, mindre)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/advmod.md" target="#">edit advmod</a>
</div>

<div about="#amod_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#amod" />
	<a id="al-sv-dep/amod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">amod</code>: <div property="rdfs:label">adjectival modifier</div></h2>
	<div property="rdfs:comment">

An adjectival modifier of a nominal is any adjectival phrase that serves
to modify the meaning of the nominal head.

~~~ sdparse
Olle äter rött kött \n Olle eats red meat
amod(kött, rött)
~~~

~~~ sdparse
Den ortodoxa kyrkans praxis \n The Orthodox Church's custom
amod(kyrkans, ortodoxa)
~~~

~~~ sdparse
De tre största hjälpinsatserna \n The three biggest helping efforts
amod(hjälpinsatserna, största)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/amod.md" target="#">edit amod</a>
</div>

<div about="#appos_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#appos" />
	<a id="al-sv-dep/appos" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">appos</code>: <div property="rdfs:label">appositional modifier</div></h2>
	<div property="rdfs:comment">

An appositional modifier of a nominal is a nominal immediately following the first that serves to define or modify it. Appositional modifiers include parenthesized examples, as well as defining abbreviations in one of these structures. 

~~~ sdparse
Olle , min bror , kom \n Olle , my brother , arrived
appos(Olle, bror)
~~~

~~~ sdparse
Sebastian ( Davids kusin ) \n Sebastian ( David 's cousin )
appos(Sebastian, kusin)
~~~

~~~ sdparse
Svensk Kärnbränslehantering AB , SKB \n Swedish Nuclear Fuel and Waste Management Company (SKB)
appos(AB, SKB)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/appos.md" target="#">edit appos</a>
</div>

<div about="#aux_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#aux" />
	<a id="al-sv-dep/aux" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">aux</code>: <div property="rdfs:label">auxiliary</div></h2>
	<div property="rdfs:comment">

An auxiliary of a clause is a [non-main verb](sv-pos/AUX) of the
clause.

Exception: An auxiliary verb used to construct the passive
[voice](sv-feat/Voice) is not labeled `aux` but [auxpass]().

~~~ sdparse
vilka funktioner den tidigare har haft \n which functions it previously has had
aux(haft, har)
~~~

~~~ sdparse
Vilka konsekvenser kan det ha ? \n What consequences can this have ?
aux(ha, kan)
~~~




	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/aux_.md" target="#">edit aux</a>
</div>

<div about="#auxpass_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#auxpass" />
	<a id="al-sv-dep/auxpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">auxpass</code>: <div property="rdfs:label">passive auxiliary</div></h2>
	<div property="rdfs:comment">

A passive auxiliary of a clause is a non-main verb of the clause which
contains the passive information.

~~~ sdparse
Kennedy blev mördad \n Kennedy was murdered
auxpass(mördad, blev)
~~~


Other auxiliaries associated with the same main verb are not labeled `auxpass` since they do not themselves indicate passive voice.

~~~ sdparse
Kennedy har blivit mördad \n Kennedy has been murdered
auxpass(mördad, blivit)
aux(mördad, har)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/auxpass.md" target="#">edit auxpass</a>
</div>

<div about="#case_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#case" />
	<a id="al-sv-dep/case" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">case</code>: <div property="rdfs:label">case marking</div></h2>
	<div property="rdfs:comment">

The `case` relation is used for any preposition in Swedish. Prepositions are treated as dependents of the noun they attach to or introduce in an "extended nominal projection". Thus, UD does not treat a preposition as a mediator between a modified word and its object. The `case` relation aims at providing a uniform analysis of prepositions and case in morphologically rich languages. 

~~~ sdparse
Individuell beskattning av arbetsinkomster \n Individual taxation of employment income
case(arbetsinkomster, av)
~~~

~~~ sdparse
Du måste börja från början \n You must start from the beginning
case(början, från)
~~~

~~~ sdparse
Nytt system för ersättning \n New system for compensation
case(ersättning, för)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/case.md" target="#">edit case</a>
</div>

<div about="#cc_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#cc" />
	<a id="al-sv-dep/cc" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cc</code>: <div property="rdfs:label">coordinating conjunction</div></h2>
	<div property="rdfs:comment">

A coordinating conjunction relation holds between the head conjunct of a coordinate structure and any of the coordinating conjunction involved in the structure. This also includes the first element in paired conjunctions like _både ... och_ "both ... and" and _antingen ... eller_ "either ... or". Note that we never treat punctuation as coordinating conjunctions.
For more on coordination, see the [conj]() relation. 

~~~ sdparse
1500 kr per barn och år \n 1500 kr per child and year
cc(barn, och)
conj(barn, år)
~~~

~~~ sdparse
både äpplen och päron \n both apples and pears
cc(äpplen, både)
cc(äpplen, och)
conj(äpplen, päron)
~~~

~~~ sdparse
äpplen , apelsiner och päron \n apples , oranges and pears
punct(äpplen, ,)
cc(äpplen, och)
conj(äpplen, päron)
conj(äpplen, apelsiner)
~~~

~~~ sdparse
Och du har inte bara en chans \n And you don't have just one chance
cc(har, Och)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/cc.md" target="#">edit cc</a>
</div>

<div about="#ccomp_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#ccomp" />
	<a id="al-sv-dep/ccomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">ccomp</code>: <div property="rdfs:label">clausal complement</div></h2>
	<div property="rdfs:comment">

A clausal complement of a verb or adjective is a dependent clause where the subject is not determined by obligatory control, either because the clause has its own overt subject or because the subject is arbitrary or determined anaphorically. (This contrasts with the _xcomp_ relation, which is used for clausal complements with obligatory control.)

~~~ sdparse
Han säger att du gillar att simma \n He says that you like to swim
ccomp(säger, gillar)
~~~

~~~ sdparse
Jag är säker på att han gjorde det \n I am certain that he did it 
ccomp(säker, gjorde) 
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/ccomp.md" target="#">edit ccomp</a>
</div>

<div about="#compound_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#compound" />
	<a id="al-sv-dep/compound" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">compound</code>: <div property="rdfs:label">compound</div></h2>
	<div property="rdfs:comment">

The `compound` relation is used in Swedish only for compounds borrowed from other languages and therefore written as two (or more) separate words. Compounds in Swedish are normally written as a single word without space between the compound elements. A subtype, [compound:prt](), is used for verb particles in phrasal verbs.

~~~ sdparse
Hon gillar corn flakes \n She likes corn flakes
dobj(gillar, flakes)
compound(flakes, corn)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/compound.md" target="#">edit compound</a>
</div>

<div about="#compound%3Aprt_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#compound" />
	<a id="al-sv-dep/compound:prt" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">compound:prt</code>: <div property="rdfs:label">verb particle</div></h2>
	<div property="rdfs:comment">

The verb particle relation _compound:prt_ is used for the particle element of a particle verb construction.

~~~ sdparse
Paketet har kommit fram \n The package has arrived
compound(kommit, fram)
~~~

~~~ sdparse
Vilka får vara med ? \n Who can join ?
compound(vara, med)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/compound-prt.md" target="#">edit compound:prt</a>
</div>

<div about="#conj_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#conj" />
	<a id="al-sv-dep/conj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">conj</code>: <div property="rdfs:label">conjunct</div></h2>
	<div property="rdfs:comment">

The conjunct relation holds between coordinated elements. We treat
coordination asymmetrically: The head of the relation is the first
conjunct and other conjuncts depend on it via the `conj` relation.

~~~ sdparse
1500 kr per barn och år \n 1500 kr per child and year
conj(barn, år)
~~~

~~~ sdparse
En sekunds tvekan eller dröjsmål eller slarv \n A second's hesitation or delay or carelessness
conj(tvekan, dröjsmål)
conj(tvekan, slarv)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/conj.md" target="#">edit conj</a>
</div>

<div about="#cop_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#cop" />
	<a id="al-sv-dep/cop" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cop</code>: <div property="rdfs:label">copula</div></h2>
	<div property="rdfs:comment">

A copula is the relation between the complement of a copular verb and
the copular verb. Copular heads are avoided when possible.

~~~ sdparse
Bill är en ärlig man \n Bill is an honest man
cop(man-5, är)
nsubj(man-5, Bill-1)
amod(man-5, ärlig)
det(man-5, en)
~~~

Prepositional phrases are annotated similarly, the only difference being that
the nominal predicate has an additional case marker.

~~~ sdparse
Bill är från Kalifornien \n Bill is from California
case(Kalifornien, från)
cop(Kalifornien, är)
nsubj(Kalifornien, Bill-1)
~~~

When an adjective or adverb is being predicated of a nominal phrase, the
adjective/adverb is the root, the nominal phrase is the nsubj, and the
copula is the cop.

~~~ sdparse
Bill är ärlig \n Bill is honest
nsubj(ärlig, Bill-1)
cop(ärlig, är)
~~~

~~~ sdparse
Det var igår \n It was yesterday
nsubj(igår, Det)
cop(igår, var)
~~~

Prepositions may also project a cop dependent.

~~~ sdparse
Ljuset är på \n The light is on
cop(på, är)
nsubj(på, Ljuset)
~~~

In predicative wh-constructions, the fronted wh-word is the head, and the copula is 
another cop.

~~~ sdparse
Vad är det ? \n What is that ?
cop(Vad, är)
nsubj(Vad, det)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/cop.md" target="#">edit cop</a>
</div>

<div about="#csubj_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#csubj" />
	<a id="al-sv-dep/csubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubj</code>: <div property="rdfs:label">clausal subject</div></h2>
	<div property="rdfs:comment">

A clausal subject is a clausal syntactic subject of a clause, i.e., the subject is itself a clause. The governor of this relation might not always be a verb: when the verb is a copular verb, the root of the clause is the complement of the copular verb.

~~~ sdparse
Vad han säger stör mig . \n What he says bothers me .
csubj(stör, säger)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/csubj.md" target="#">edit csubj</a>
</div>

<div about="#csubjpass_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#csubjpass" />
	<a id="al-sv-dep/csubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubjpass</code>: <div property="rdfs:label">clausal passive subject</div></h2>
	<div property="rdfs:comment">

A clausal passive subject is a clausal syntactic subject of a passive
clause. In the example below, *att hon ljög* is the subject.

~~~ sdparse
Att hon ljög misstänktes av alla . \n That she lied was suspected by everyone .
csubjpass(misstänktes, ljög)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/csubjpass.md" target="#">edit csubjpass</a>
</div>

<div about="#dep_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#dep" />
	<a id="al-sv-dep/dep" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dep</code>: <div property="rdfs:label">unspecified dependency</div></h2>
	<div property="rdfs:comment">

A dependency is labeled as `dep` when a system is unable to
determine a more precise dependency relation between two words. This
may be because of a weird grammatical construction, a limitation in
software, a parser error, or because of an unresolved long distance 
dependency.

In the current version of the Swedish UD treebank, the _dep_ relation is not used at all.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/dep.md" target="#">edit dep</a>
</div>

<div about="#det_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#det" />
	<a id="al-sv-dep/det" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">det</code>: <div property="rdfs:label">determiner</div></h2>
	<div property="rdfs:comment">

A determiner is the relation between the head of a nominal phrase and its determiner. 

~~~ sdparse
Den engelska parken är vacker \n The English park is beautiful
det(parken, Den)
~~~

~~~ sdparse
Vilken bok föredrar du ? \n Which book do you prefer ?
det(bok, Vilken)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/det.md" target="#">edit det</a>
</div>

<div about="#discourse_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#discourse" />
	<a id="al-sv-dep/discourse" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">discourse</code>: <div property="rdfs:label">discourse element</div></h2>
	<div property="rdfs:comment">

This is used for interjections and other discourse particles and elements, which are not clearly linked to the structure of the sentence except in an expressive way.

~~~ sdparse
Wow , det var kul :) \n Wow , that was fun :)
discourse(kul, :)-6)
discourse(kul, Wow)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/discourse.md" target="#">edit discourse</a>
</div>

<div about="#dislocated_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#dislocated" />
	<a id="al-sv-dep/dislocated" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dislocated</code>: <div property="rdfs:label">dislocated elements</div></h2>
	<div property="rdfs:comment">

The `dislocated` relation is used for fronted or postposed elements that do not fulfill the usual core grammatical 
relations of a sentence. Dislocated elements are attached to the same governor as the dependent that they double 
for.

~~~ sdparse
Peter , honom gillar jag inte \n Peter, I don't like him
dislocated(gillar, Peter)
dobj(gillar, honom)
~~~

A frequent case in Swedish is that of an adverbial clause resumed by the pronominal adverb *så*:

~~~ sdparse
Släpper vi in britterna , så drar de med sig danskar \n If we let the Brits in they'll bring the Danish with them
dislocated(drar, Släpper)
advcl(drar, så)
~~~

In addition, the `dislocated` relation is used for the focus element in a cleft sentence. This is a slight
abuse of the relation, because the focus element is not a dislocated dependent of its syntactic head, but 
rather of the predicate in the relative clause making up the second part of the cleft construction. 

~~~ sdparse
Det var Peter som gjorde det \n It was Peter who did it
dislocated(var, Peter)
expletive(var, Det)
acl:relcl(Peter, gjorde)
nsubj(gjorde, som)
dobj(gjorde, det)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/dislocated.md" target="#">edit dislocated</a>
</div>

<div about="#dobj_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#dobj" />
	<a id="al-sv-dep/dobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dobj</code>: <div property="rdfs:label">direct object</div></h2>
	<div property="rdfs:comment">

A direct object is a nominal which is the (accusative) object of the verbal predicate. 

~~~ sdparse
Han äter en smörgås . \n He eats a sandwich .
dobj(äter, smörgås)
~~~

If there is only one object present, it is always analyzed as _dobj_ regardless of the semantic relation to the predicate. If there are two objects, the one most directly related to the verb is treated as the direct object.

~~~ sdparse
Han informerar dig . \n He informs you .
dobj(informerar, dig)
~~~

~~~ sdparse
Han skickar dig information . \n He sends you information .
dobj(skickar, information)
iobj(skickar, dig)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/dobj.md" target="#">edit dobj</a>
</div>

<div about="#expl_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#expl" />
	<a id="al-sv-dep/expl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">expl</code>: <div property="rdfs:label">expletive</div></h2>
	<div property="rdfs:comment">

This relation captures an existential *det* in extraposition constructions. Note that in some dialects of Swedish *där* can be used in the same way. Only *det* is currently attested in the treebank. There is further discussion and examples on the universal dependency page ([u-dep/expl]()).

~~~ sdparse
Det finns inga vetenskapliga belägg \n There is no scientific evidence
expl(finns, Det)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/expl.md" target="#">edit expl</a>
</div>

<div about="#foreign_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#foreign" />
	<a id="al-sv-dep/foreign" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">foreign</code>: <div property="rdfs:label">foreign words</div></h2>
	<div property="rdfs:comment">

The `foreign` relation can be used to label sequences of foreign words. These are given
a linear analysis: the head is the first token in the foreign phrase.

~~~ sdparse
I anslutning till satsen consensus facit nuptiam
foreign(consensus, facit)
foreign(consensus, nuptiam)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/foreign.md" target="#">edit foreign</a>
</div>

<div about="#goeswith_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#goeswith" />
	<a id="al-sv-dep/goeswith" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">goeswith</code>: <div property="rdfs:label">goes with</div></h2>
	<div property="rdfs:comment">

This relation links two parts of a word that are separated in text
that is not well edited.
The head is in some sense the “main” part, often the second part.

~~~ sdparse
Frivillig sär beskattning \n Voluntary individual taxation
goeswith(beskattning, sär)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/goeswith.md" target="#">edit goeswith</a>
</div>

<div about="#iobj_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#iobj" />
	<a id="al-sv-dep/iobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">iobj</code>: <div property="rdfs:label">indirect object</div></h2>
	<div property="rdfs:comment">

An indirect object is a nominal which is the second object of the verb, often corresponding to a dative object.

~~~ sdparse
Han skickar mig ett brev . \n He sends me a letter .
iobj(skickar, mig)
~~~

In Swedish, the indirect object can never be constructed with a preposition. In that case, the _nmod_ relation is used even if the meaning is very similar to that of an indirect object.

~~~ sdparse
Han skickar ett brev till mig . \n He sends a letter to me .
nmod(skickar, mig)
case(mig, till)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/iobj.md" target="#">edit iobj</a>
</div>

<div about="#list_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#list" />
	<a id="al-sv-dep/list" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">list</code>: <div property="rdfs:label">list</div></h2>
	<div property="rdfs:comment">

The `list` relation is used for chains of comparable items. It is not currently attested in the Swedish treebank.

Web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences. Email signatures in particular contain these structures, in the form of contact information: the different contact information items are labeled as `list`; the key-value pair relations are labeled as [appos]().

In lists with more than two items, all items of the list shoud modify the first one.

~~~ sdparse
Steve Jones Mobil: 555-9814 Mejl: jones@abc.edf
name(Steve-1, Jones-2)
list(Steve-1, Mobil:-3)
list(Steve-1, Mejl:-5)
appos(Mobil:-3, 555-9814-4)
appos(Mejl:-5, jones@abc.edf-6)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/list.md" target="#">edit list</a>
</div>

<div about="#mark_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#mark" />
	<a id="al-sv-dep/mark" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mark</code>: <div property="rdfs:label">marker</div></h2>
	<div property="rdfs:comment">

A marker is the word introducing a clause subordinate to another clause. The marker is a dependent of the subordinate clause head. 

~~~ sdparse
Han säger att du gillar att simma \n He says that you like to swim
mark(gillar, att-3)
~~~

~~~ sdparse
Om det regnar , blir man blöt \n If it rains , one gets wet
mark(regnar, Om)
~~~

The infinitive marker *att* is analyzed as a `mark`.

~~~ sdparse
Det är svårt att tolka \n It is difficult to interpret
mark(tolka, att)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/mark.md" target="#">edit mark</a>
</div>

<div about="#mwe_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#mwe" />
	<a id="al-sv-dep/mwe" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mwe</code>: <div property="rdfs:label">multi-word expression</div></h2>
	<div property="rdfs:comment">

The multi-word expression (modifier) relation is one of the three
relations ([compound](), `mwe`, [name]()) for compounding.
It is used for certain fixed grammaticized expressions that behave
like function words or short adverbials. The first word is always
taken as the head, with all subsequent words as direct dependents.

~~~ sdparse
i dag \n today
mwe(i, dag)
~~~

~~~ sdparse
över huvud taget \n at all
mwe(över, huvud)
mwe(över, taget)
~~~

~~~ sdparse
när det gäller \n when it comes to
mwe(när, det)
mwe(när, gäller)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/mwe.md" target="#">edit mwe</a>
</div>

<div about="#name_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#name" />
	<a id="al-sv-dep/name" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">name</code>: <div property="rdfs:label">name</div></h2>
	<div property="rdfs:comment">

The name relation is one of the three relations for compounding in UD (together
with [compound]() and [mwe]()).
It is used for proper nouns constituted of multiple nominal
elements. For example, `name` would be used between the words of
_Hillary Rodham Clinton, New York,_ or _Carl XVI Gustaf_ but not to
replace the usual relations in a phrasal or clausal name like _The
king of Sweden_ or the novels _The Lord of the Rings_ and _Captured By
Aliens._

Words joined by `name` should all be part of a minimal noun phrase;
otherwise regular syntactic relations should be used.  This is
basically similar to the treatment of noun compounds with
[compound](), except that in many cases parts of the name may be
another nominal element such as an adjective _(United Airlines)._

In general, names are annotated in a flat, head-initial structure, in
which all words in the name modify the first one using the `name`
label.

~~~ sdparse
Carl XVI Gustaf
name(Carl-1, Gustaf-3)
name(Carl-1, XVI-2)
~~~

For names with a clear syntactic modification structure, the dependencies should instead reflect the syntactic modification structure using regular syntactic relations, as in:

~~~ sdparse
Statens veterinärmedicinska anstalt \n The government institute for veterinary medicine
nmod:poss(anstalt, Statens)
amod(anstalt, veterinärmedicinska)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/name.md" target="#">edit name</a>
</div>

<div about="#neg_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#neg" />
	<a id="al-sv-dep/neg" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">neg</code>: <div property="rdfs:label">negation modifier</div></h2>
	<div property="rdfs:comment">

The negation modifier is the relation between a negation word and the word it modifies.

~~~ sdparse
En social gemenskap existerar inte \n A social community doesn't exist
neg(existerar, inte)
~~~

~~~ sdparse
Det är inte fråga om att hjälpa till \n It's not a question of helping
neg(fråga, inte)
~~~

~~~ sdparse
De är icke jämförbara \n They are not comparable
neg(jämförbara, icke)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/neg.md" target="#">edit neg</a>
</div>

<div about="#nmod_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-sv-dep/nmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod</code>: <div property="rdfs:label">nominal modifier</div></h2>
	<div property="rdfs:comment">

The `nmod` relation is used for nominal modifiers of nouns or clausal
predicates. `nmod` is a noun functioning as a non-core (oblique)
argument or adjunct. In Swedish, `nmod` is used for prepositional complements:

~~~ sdparse
Ekonomiska bidrag till staten \n Financial contributions to the state
nmod(bidrag, staten)
case(staten, till)
~~~

~~~ sdparse
Mamma har hand om barnen \n Mother takes care of the children
nmod(har, barnen)
case(barnen, om)
~~~

~~~ sdparse
Han växte upp i en kollektiv miljö \n He grew up in a collective environment
nmod(växte, miljö)
case(miljö, i)
~~~

Two subtypes of `nmod` are introduced in Swedish: [nmod:poss]() for for possessive/genitive modifiers and [nmod:agent]() for agents of passive verbs.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/nmod.md" target="#">edit nmod</a>
</div>

<div about="#nmod%3Aagent_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-sv-dep/nmod:agent" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:agent</code>: <div property="rdfs:label">agent nominal modifier</div></h2>
	<div property="rdfs:comment">

The relation `nmod:agent` is used for agents of passive verbs

~~~ sdparse
Börjar hennes jobb att delas av den moderne mannen ? \n Will her job start being shared by the modern man ?
nmod:agent(delas, mannen)
case(manne, av)
~~~

~~~ sdparse
Samhällsordningen hotas av social revolution \n Social order is threatened by social revolution
nmod:agent(hotas, revolution)
case(revolution, av)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/nmod-agent.md" target="#">edit nmod:agent</a>
</div>

<div about="#nmod%3Aposs_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-sv-dep/nmod:poss" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod:poss</code>: <div property="rdfs:label">possessive nominal modifier</div></h2>
	<div property="rdfs:comment">

The relation `nmod:poss` is used for a genitive/possessive nominal modifier, expressed either by a nominal in the genitive or by a possessive determiner.

~~~ sdparse
Livets hårda sida \n The difficult side of life
nmod:poss(sida, Livets)
~~~

~~~ sdparse
Alla våra hem \n All our homes
nmod:poss(hem, våra)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/nmod-poss.md" target="#">edit nmod:poss</a>
</div>

<div about="#nsubj_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubj" />
	<a id="al-sv-dep/nsubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubj</code>: <div property="rdfs:label">nominal subject</div></h2>
	<div property="rdfs:comment">

The dependency type `nsubj` marks nominal subjects of a clause. Subjects are direct dependents of the main predicate of the clause, which may be a verb, noun or adjective.

~~~ sdparse
Pappa hjälper till med tvätten . \n Dad helps with the laundry .
nsubj(hjälper, Pappa)
~~~

~~~ sdparse
Pappa är sjuk . \n Dad is sick .
nsubj(sjuk, Pappa)
~~~

~~~ sdparse
Pappa är en bra kock . \n Dad is a good cook .
nsubj(kock, Pappa)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/nsubj.md" target="#">edit nsubj</a>
</div>

<div about="#nsubjpass_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubjpass" />
	<a id="al-sv-dep/nsubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubjpass</code>: <div property="rdfs:label">passive nominal subject</div></h2>
	<div property="rdfs:comment">

A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.

~~~ sdparse
En ändring krävs av politiker . \n A change is required by politicians .
nsubjpass(krävs, ändring)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/nsubjpass.md" target="#">edit nsubjpass</a>
</div>

<div about="#nummod_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#nummod" />
	<a id="al-sv-dep/nummod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nummod</code>: <div property="rdfs:label">numeric modifier</div></h2>
	<div property="rdfs:comment">

A numeric modifier of a noun is any number phrase that serves to
modify the meaning of the noun with a quantity.

~~~ sdparse
Sam åt 3 får \n Sam ate 3 sheep
nummod(får, 3)
~~~

~~~ sdparse
År 1962 tog nära 13 procent studenten \n In 1962 almost 13 percent took the graduation exam
nummod(År, 1962)
nummod(procent, 13)
~~~

~~~ sdparse
Erik tjänar ungefär 400 kr \n Erik earns approximately 400 kr
nummod(kr, 400)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/nummod.md" target="#">edit nummod</a>
</div>

<div about="#parataxis_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#parataxis" />
	<a id="al-sv-dep/parataxis" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">parataxis</code>: <div property="rdfs:label">parataxis</div></h2>
	<div property="rdfs:comment">

The parataxis relation (from Greek for "place side by side") is a relation between the main verb of a clause and other sentential elements, such as a sentential parenthetical, a clause after a ":" or a ";", or two sentences placed side by side without any explicit coordination or subordination. More information can be found on the universal dependency page ([u-dep/parataxis]())

~~~ sdparse
Barn leker nästan jämt , leken är deras arbete \n Children play all the time , play is their work  
parataxis(leker, arbete)
~~~

~~~ sdparse
Barn har rätt till fritid ( se nedan ) \n Children have a right to free time ( see below )
parataxis(har, se)
~~~

~~~ sdparse
Det är tanken : barn är framtiden \n That is the thought : children are the future
parataxis(tanken, framtiden)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/parataxis.md" target="#">edit parataxis</a>
</div>

<div about="#punct_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#punct" />
	<a id="al-sv-dep/punct" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">punct</code>: <div property="rdfs:label">punctuation</div></h2>
	<div property="rdfs:comment">

This is used for any piece of punctuation in a clause, regardless of its function. The punctuation mark is attached to the head of the phrase or clause to which it belongs unless this introduces a non-projective dependency. More discussion on punctuation can be found on the universal dependency page ([u-dep/punct]()).

~~~ sdparse
Och alla vinsterna och skattefria ! \n And all profits are tax-free !
punct(skattefria, !)
~~~

~~~ sdparse
Om det regnar , blir man blöt . \n If it rains , one gets wet .
punct(regnar, ,)
punct(blir, .)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/punct.md" target="#">edit punct</a>
</div>

<div about="#remnant_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#remnant" />
	<a id="al-sv-dep/remnant" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">remnant</code>: <div property="rdfs:label">remnant in ellipsis</div></h2>
	<div property="rdfs:comment">

The remnant relation is used to analyze cases of ellipsis where there is no function word that can be promoted to take the place of the elided content word. For a full discussion of its use, see the universal dependency description ([u-dep/remnant]()).

~~~ sdparse
Marie åkte till Paris och Miriam till Prague \n Marie went to Paris and Miriam to Prague
nsubj(åkte, Marie-1)
nmod(åkte-2, Paris-4)
case(Paris-4, till-3)
cc(åkte, och)
remnant(Marie-1, Miriam-6)
case(Prague-8, till)
remnant(Paris-4, Prague-8)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/remnant.md" target="#">edit remnant</a>
</div>

<div about="#reparandum_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#reparandum" />
	<a id="al-sv-dep/reparandum" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">reparandum</code>: <div property="rdfs:label">overridden disfluency</div></h2>
	<div property="rdfs:comment">

The `reparandum` relation is used to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair. There are currently
no attested uses of this relation in the Swedish treebank.

~~~ sdparse
Gå till höge- till vänster . \n Go to the righ- to the left .
nmod(Gå, vänster)
reparandum(vänster, höge-)
case(höge-, till-2)
case(vänster, till-4)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/reparandum.md" target="#">edit reparandum</a>
</div>

<div about="#root_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#root" />
	<a id="al-sv-dep/root" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">root</code>: <div property="rdfs:label">root</div></h2>
	<div property="rdfs:comment">

The `root` grammatical relation points to the root of the sentence. A fake node "ROOT" is used as the governor. The ROOT node is indexed with "0", since the indices of real words in the sentence start at 1. 

~~~ sdparse
ROOT Jag älskar pommes frites . \n ROOT I love French fries .
root(ROOT, älskar)
~~~

~~~ sdparse
ROOT Bill är en ärlig man \n ROOT Bill is an honest man
root(ROOT, man-6)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/root.md" target="#">edit root</a>
</div>

<div about="#vocative_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#vocative" />
	<a id="al-sv-dep/vocative" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">vocative</code>: <div property="rdfs:label">vocative</div></h2>
	<div property="rdfs:comment">

The *vocative* relation is used to mark a dialogue participant addressed in text (common in conversations, emails and newsgroup postings). The relation links the addressee's name to its host sentence.

~~~ sdparse
Killar , ta det lungt ! \n Guys , take it easy!
vocative(ta, Killar)
~~~

~~~ sdparse
David , hur är läget ? \n David, how 's it going ?
vocative(hur, David)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/vocative.md" target="#">edit vocative</a>
</div>

<div about="#xcomp_sv" property="rdf:type" resource="#dep_sv">
	<div property="rdf:type" resource="../../u/dep/all.html#xcomp" />
	<a id="al-sv-dep/xcomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">xcomp</code>: <div property="rdfs:label">open clausal complement</div></h2>
	<div property="rdfs:comment">

An open clausal complement (`xcomp`) of a verb or an adjective is a predicative or clausal complement without its own subject. The reference of the subject is necessarily determined by an argument external to the xcomp (normally by the object of the next higher clause, if there is one, or else by the subject of the next higher clause). These complements are always non-finite, and they are complements (arguments of the higher verb or adjective) rather than adjuncts/modifiers, such as a purpose clause. The name `xcomp` is borrowed from Lexical-Functional Grammar. 

~~~ sdparse
Han säger att du gillar att simma \n He says that you like to swim
xcomp(gillar, simma)
~~~

~~~ sdparse
Nu kan vi låta barnen studera om de vill \n Now we can let the children study if they want to
xcomp(låta, studera)
~~~

~~~ sdparse
Jag betraktar honom som min vän \n I consider him as my friend
xcomp(betraktar, vän)
~~~



	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_sv-dep/xcomp.md" target="#">edit xcomp</a>
</div>


      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html
	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'sv-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
