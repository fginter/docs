<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml"
	prefix:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
	prefix:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
	prefix:oliasystem="http://purl.org/olia/system.owl#"
	prefix:xsd="http://www.w3.org/2001/XMLSchema#"
>

  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Dependencies</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
	
          <span class="header-text"><a href="http://universaldependencies.org/#language-cs">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          
<h1 id="dependencies">Dependencies</h1>

<p><span about="." property="rdf:type" resource="owl:Ontology">
	<span property="owl:imports" resource=" https://www.w3.org/2012/pyRdfa/extract?uri=http://universaldependencies.org/docs/u/dep/all.html&amp;format=xml&amp;rdfagraph=output&amp;vocab_expansion=false&amp;rdfa_lite=false&amp;embedded_rdf=true&amp;space_preserve=false&amp;vocab_cache=true&amp;vocab_cache_report=false&amp;vocab_cache_refresh=false"></span>
</span></p>

<p>Note: <i>nmod</i>, <i>neg</i>, and <i>punct</i> appear
in two places.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a>nsubj</a></td>
	  <td><a>csubj</a></td>
	</tr>
	<tr>
	  <td><a>nsubjpass</a></td>
	  <td><a>csubjpass</a></td>
	</tr>
	<tr>
	  <td><a>dobj</a></td>
	  <td><a>ccomp</a></td>
	  <td><a>xcomp</a></td>
	</tr>
	<tr>
	  <td><a>iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Non-core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td><a>advcl</a></td>
	  <td><a>advmod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>advmod:emph</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Special clausal dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a>vocative</a></td>
	  <td><a>aux</a></td>
	  <td><a>mark</a></td>
	</tr>
	<tr>
	  <td><a>discourse</a></td>
	  <td><a>auxpass</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>expl</a></td>
	  <td>↳<a>auxpass:reflex</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a>cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Noun dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td><a>acl</a></td>
	  <td><a>amod</a></td>
	</tr>
	<tr>
	  <td><a>appos</a></td>
	  <td>&nbsp;</td>
	  <td><a>det</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>det:numgov</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>det:nummod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>nummod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>nummod:gov</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Compounding and unanalyzed</strong></td></tr>
	<tr>
	  <td><a>compound</a></td>
	  <td><a>mwe</a></td>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td><a>name</a></td>
	  <td><a>foreign</a></td>
	  <td></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Coordination</strong></td></tr>
	<tr>
	  <td><a>conj</a></td>
	  <td><a>cc</a></td>
	  <td><a>punct</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Case-marking, prepositions, possessive</strong></td></tr>
	<tr>
	  <td><a>case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Loose joining relations</strong></td></tr>
	<tr>
	  <td><a>list</a></td>
	  <td><a>parataxis</a></td>
	  <td><a>remnant</a></td>
	</tr>
	<tr>
	  <td><strike>dislocated</strike></td>
	  <td></td><td><a>reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Other</strong></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<p><span about="#dep_cs" property="rdfs:label" style="visibility: hidden">Dependencies</span>
<span about="#dep_cs" property="rdfs:subClassOf" resource="_:cs">
	<span about="_:cs" property="rdf:type" resource="owl:Restriction">
		<span property="owl:onProperty" resource="http://purl.org/dc/terms/language"></span>
		<span property="owl:hasValue" lang="" style="visibility: hidden">cs</span>
	</span>
</span></p>

<hr />

<div about="#acl_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#acl" />
	<a id="al-cs-dep/acl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">acl</code>: <div property="rdfs:label">clausal modifier of noun</div></h2>
	<div property="rdfs:comment">

`acl` stands for finite and non-finite clauses that modify a nominal.  The `acl` relation 
contrasts with the [advcl]() relation, which is used for adverbial clauses
that modify a predicate. The head of the `acl` relation is the noun
that is modified, and the dependent is the head of the clause that
modifies the noun.

~~~ sdparse
muž , o kterém jsem mluvil \n man , about whom I-have talked
acl(muž, mluvil)
acl(man, talked)
~~~

This relation is also used for optional depictives.
The adjective is taken to modify the nominal of which it provides a secondary predication.
See [u-dep/xcomp]() for further discussion of resultatives and depictives.

~~~ sdparse
Alena vstoupila do místnosti smutná . \n Alena entered to room sad .
acl(Alena-1, smutná)
acl(Alena-8, sad)
~~~

~~~ sdparse
Namaloval svou ženu nahou . \n He-painted his wife naked .
acl(ženu, nahou)
acl(wife, naked)
~~~

Czech also allows finite clausal complements for nouns with 
a subset of nouns like *fact* or *report*.
These look roughly like relative clauses, but do not have any omitted role in the dependent clause.
These are also analyzed as `acl`.

~~~ sdparse
Příčinou není fakt , že by kina navštívilo víc diváků . \n Cause is-not the-fact , that would cinemas visit more filmgoers .
acl(fakt, navštívilo)
acl(the-fact, visit)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/acl.md" target="#">edit acl</a>
</div>

<div about="#advcl_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#advcl" />
	<a id="al-cs-dep/advcl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advcl</code>: <div property="rdfs:label">adverbial clause modifier</div></h2>
	<div property="rdfs:comment">

An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.),
as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an [advmod]()) and the dependent is the main predicate of the clause.

~~~ sdparse
K nehodě došlo , když přicházela noc . \n To accident it-came , when was-falling night .
advcl(došlo, přicházela)
advcl(it-came, was-falling)
~~~

~~~ sdparse
Jestliže víš , kdo to udělal , měl bys to říct učiteli . \n If you-know , who it did , should you it tell teacher .
advcl(měl, víš)
advcl(should, you-know)
~~~

~~~ sdparse
Spěchal , aby přišel včas . \n He-rushed , in-order-to come in-time .
advcl(Spěchal, přišel)
advcl(He-rushed, come)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advcl.md" target="#">edit advcl</a>
</div>

<div about="#advmod_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#advmod" />
	<a id="al-cs-dep/advmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advmod</code>: <div property="rdfs:label">adverbial modifier</div></h2>
	<div property="rdfs:comment">

An adverbial modifier of a word is a (non-clausal) [adverb](cs-pos/ADV)
or adverbial phrase that serves to modify the meaning of the word.

Note that in the Czech grammatical tradition, the term _adverbial modifier_ covers
constituents that function like adverbs regardless whether they are realized
by adverbs, adpositional phrases, or nouns in particular morphological 
[cases](cs-feat/Case).
We differentiate adverbials realized as adverbs (`advmod`) and
adverbials realized by noun phrases or adpositional phrases
([nmod]()).

~~~ sdparse
geneticky upravené potraviny \n genetically modified food
advmod(upravené, geneticky)
advmod(modified, genetically)
~~~

~~~ sdparse
méně často \n less often
advmod(často, méně)
advmod(often, less)
~~~

~~~ sdparse
Kam/ADV chcete/VERB jít/VERB zítra/ADV ?/PUNCT \n Where do-you-want to-go tomorrow ?
advmod(jít, Kam)
advmod(jít, zítra)
advmod(to-go, Where)
advmod(to-go, tomorrow)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advmod.md" target="#">edit advmod</a>
</div>

<div about="#advmod%3Aemph_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#advmod" />
	<a id="al-cs-dep/advmod:emph" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">advmod:emph</code>: <div property="rdfs:label">emphasizing word, intensifier</div></h2>
	<div property="rdfs:comment">

This is a special class of [adverbial modifiers](advmod).
It corresponds to the words that are attached in the analytical layer of PDT with the label `AuxZ`.
In the tectogrammatical layer they often get the label (functor) `RHEM` (rhematizers).

While other adverbial modifiers usually modify verbs, adjectives or adverbs, these emphasizers often modify noun phrases,
including prepositional phrases.

~~~ sdparse
zvlášť v pondělí \n especially on Monday
advmod:emph(pondělí, zvlášť)
advmod:emph(Monday, especially)
~~~

~~~ sdparse
jen 15 procent \n only 15 percent
advmod:emph(procent, jen)
advmod:emph(percent, only)
~~~

Other examples:

* _Mohli by obvinit <b>i</b> některého ministra._ “They could prosecute <b>also/even</b> a minister.”
* _Začnou <b>až</b> o měsíc později._ lit. _They-will-start <b>even</b> by month later._ “They will start one month later.” (_Až_ expresses that the speaker or the listener did not expect the thing to happen <b>that</b> late.)
* _<b>Ani</b> vojáci o to nemají zájem._ “<b>Not even</b> soldiers are interested in it.”
* _Hraje <b>už</b> v sobotu._ “He will play <b>already</b> on Saturday.”
* _Chceme se sejít <b>ještě</b> tento týden._ lit. _We-want to meet <b>still</b> this week._ “We want to meet before this week ends.”
* _u <b>asi</b> 20 titulů_ “by <b>around/approximately</b> 20 items”
* _Dá se to dokumentovat <b>právě</b> na početné skupině dětí._ “It can be shown <b>just</b> on a large group of children.”


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advmod-emph.md" target="#">edit advmod:emph</a>
</div>

<div about="#amod_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#amod" />
	<a id="al-cs-dep/amod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">amod</code>: <div property="rdfs:label">adjectival modifier</div></h2>
	<div property="rdfs:comment">

An adjectival modifier of a noun is any adjectival phrase that serves
to modify the meaning of the noun.

Exception: if the modifying adjectival word is pronominal (i.e. tagged [cs-pos/DET]()),
the relation is [det]() instead of `amod`.

~~~ sdparse
Václav jí vepřové maso . \n Václav eats pork meat .
amod(maso, vepřové)
amod(meat, pork)
~~~

~~~ sdparse
Václav si vzal třímiliónovou půjčku . \n Václav himself took-out three-million loan .
amod(půjčku, třímiliónovou)
amod(loan, three-million)
~~~

~~~ sdparse
První závodník byl rychlý . \n First racer was fast .
amod(závodník, První)
amod(racer, First)
nsubj(rychlý, závodník)
nsubj(fast, racer)
~~~

~~~ sdparse
Rychlý závodník byl první . \n Fast racer was first .
amod(závodník, Rychlý)
amod(racer, Fast)
nsubj(první, závodník)
nsubj(first, racer)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/amod.md" target="#">edit amod</a>
</div>

<div about="#appos_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#appos" />
	<a id="al-cs-dep/appos" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">appos</code>: <div property="rdfs:label">appositional modifier</div></h2>
	<div property="rdfs:comment">

An appositional modifier of a noun is a nominal immediately following
the first noun that serves to define or modify that noun. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.

~~~ sdparse
Karel IV . , římský císař a český král , vládl ve 14 . století . \n Charles IV . , Roman Emperor and Czech king , ruled in 14 th century .
appos(Karel, císař)
appos(Charles, Emperor)
conj(císař, král)
conj(Emperor, king)
~~~

~~~ sdparse
Občanská demokratická strana ( ODS ) \n Civic Democratic Party ( ODS )
appos(strana, ODS-5)
appos(Party, ODS-12)
~~~

There is a slight deviation from the [universal](u-dep/appos) standard in case of more than one appositive nominal.
Instead of attaching them all to the first noun, all the appositive modifiers are put together in coordination,
then attached as `appos` to the modified noun.
This is done regardless whether the appositives are joined by a coordinating conjunction or just a comma.

~~~ sdparse
Přijel Michal , můj bratr a Davidův bratranec . \n Came Michal , my brother and David's cousin .
appos(Michal-2, bratr)
appos(Michal-12, brother)
conj(bratr, bratranec)
conj(brother, cousin)
~~~

~~~ sdparse
Michal , můj bratr , Davidův bratranec , přijede zítra . \n Michal , my brother , David's cousin , will-come tomorrow .
appos(Michal-1, bratr)
appos(Michal-13, brother)
conj(bratr, bratranec)
conj(brother, cousin)
~~~

`appos` is also used to link key-value pairs in addresses, signatures, etc. (see also the [list]() label):

~~~ sdparse
Jan Novák , tel . : 777-000-111 , e-mail : novak@ab.cz
name(Novák, Jan)
list(Novák, tel)
list(Novák, e-mail)
appos(tel, 777-000-111)
appos(e-mail, novak@ab.cz)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/appos.md" target="#">edit appos</a>
</div>

<div about="#aux_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#aux" />
	<a id="al-cs-dep/aux" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">aux</code>: <div property="rdfs:label">auxiliary</div></h2>
	<div property="rdfs:comment">

An auxiliary of a clause is a form of the [auxiliary verb](cs-pos/AUX) _být_ “to be”
used to construct the periphrastic future tense, past tense or conditional.

Exception: Auxiliary verb used to construct the passive
[voice](cs-feat/Voice) is not labeled `aux` but [auxpass]().

Note that besides `aux` and `auxpass`, the verb _být_ may also act as a [copula](cop)
and as the main verb.

~~~ sdparse
Přijel jsem včera . \n Arrived I-have yesterday .
aux(Přijel, jsem)
aux(Arrived, I-have)
~~~

~~~ sdparse
Zítra budu přednášet na univerzitě . \n Tomorrow I-will give-a-talk at university .
aux(přednášet, budu)
aux(give-a-talk, I-will)
~~~

~~~ sdparse
Přišel bych dříve , ale ujel mi vlak . \n Come I-would earlier , but missed my train .
aux(Přišel, bych)
aux(Come, I-would)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/aux_.md" target="#">edit aux</a>
</div>

<div about="#auxpass_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#auxpass" />
	<a id="al-cs-dep/auxpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">auxpass</code>: <div property="rdfs:label">passive auxiliary</div></h2>
	<div property="rdfs:comment">

A passive auxiliary of a clause is a form of the [auxiliary verb](cs-pos/AUX) _být_ “to be”
used to construct the periphrastic passive voice (in any tense or in the infinitive).

~~~ sdparse
Kennedy byl zabit . \n Kennedy was killed .
auxpass(zabit, byl)
auxpass(killed, was)
~~~

~~~ sdparse
Kennedy bude zabit . \n Kennedy will-be killed .
auxpass(zabit, bude)
auxpass(killed, will-be)
~~~

~~~ sdparse
Kennedy netušil , že jeho osudem je být zabit . \n Kennedy did-not-anticipate that his fate is to-be killed .
auxpass(zabit, být)
auxpass(killed, to-be)
~~~

Note that the passive participle may be also used as nominal predicate with [copula](cop).
Hence it may be difficult to distinguish a passive construction from a copula construction.
The former focuses on the process while the latter emphasizes the result.

- Passive:

~~~ sdparse
Smlouva byla podepsána v Bílém domě . \n Contract was signed in White House .
auxpass(podepsána, byla)
auxpass(signed, was)
~~~

- Copula:

~~~ sdparse
Smlouva byla podepsána červeným inkoustem . \n Contract was signed in-red ink .
cop(podepsána, byla)
cop(signed, was)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/auxpass.md" target="#">edit auxpass</a>
</div>

<div about="#auxpass%3Areflex_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#auxpass" />
	<a id="al-cs-dep/auxpass:reflex" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">auxpass:reflex</code>: <div property="rdfs:label">reflexive pronoun used in reflexive passive</div></h2>
	<div property="rdfs:comment">

Reflexive pronouns (see the feature [cs-feat/Reflex]()) are used in various constructions in Czech,
including so-called _reflexive passive._
In PDT, their relation to the verb is labeled `AuxR`.
The corresponding label in Czech UD is called `auxpass:reflex`.

~~~ sdparse
To se řekne snadno . \n It is said easily .
auxpass:reflex(řekne, se)
auxpass:reflex(said, is)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/auxpass-reflex.md" target="#">edit auxpass:reflex</a>
</div>

<div about="#case_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#case" />
	<a id="al-cs-dep/case" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">case</code>: <div property="rdfs:label">case marking</div></h2>
	<div property="rdfs:comment">

Czech uses a combination of oblique morphological cases and prepositions to express semantic case.
Unlike in the original annotation of the Prague Dependency Treebank, prepositions in UD are treated as dependents
of the noun they attach to. The relation between the noun and the preposition is labeled `case`.

~~~ sdparse
V pátek.Acc jsme si cestou.Ins do Francie.Gen povídali o té události.Loc . \n On Friday we-have ourselves during-the-journey to France talked about the event .
case(pátek.Acc, V)
case(Friday, On)
case(Francie.Gen, do)
case(France, to)
case(události.Loc, o)
case(event, about)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/case.md" target="#">edit case</a>
</div>

<div about="#cc_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#cc" />
	<a id="al-cs-dep/cc" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cc</code>: <div property="rdfs:label">coordinating conjunction</div></h2>
	<div property="rdfs:comment">

For more on coordination, see the [conj]() relation.
A `cc` is the relation between the first conjunct and
the [coordinating conjunction](cs-pos/CONJ) delimiting another conjunct.
(Note: different dependency grammars have different treatments of coordination.
We take the first conjunct as the head of the coordination.)

~~~ sdparse
Je to starý a moudrý muž . \n Is he old and wise man .
cc(starý, a)
cc(old, and)
~~~

A coordinating conjunction may also appear at the beginning of a
sentence. This is also called a `cc`, and it depends on the root
predicate of the sentence.
(In fact there is a coordination that spans multiple sentences.
We cannot attach a word to the first conjunct because it is in another sentence.
Thus we attach it to the first conjunct available in the current sentence: its main predicate.)

~~~ sdparse
A pak jsme odešli . \n And then we-have left .
cc(odešli, A)
cc(left, And)
~~~

~~~ sdparse
Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
dobj(Máme, jablka)
dobj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(jablka, a)
cc(apples, and)
punct(jablka, ,-3)
punct(jablka, ,-5)
punct(apples, ,-13)
punct(apples, ,-15)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/cc.md" target="#">edit cc</a>
</div>

<div about="#ccomp_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#ccomp" />
	<a id="al-cs-dep/ccomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">ccomp</code>: <div property="rdfs:label">clausal complement</div></h2>
	<div property="rdfs:comment">

A clausal complement of a verb or adjective is a dependent clause 
which is a core argument. That is, it functions like an object of the verb, or
adjective.

~~~ sdparse
Říká , že ráda plaveš . \n He-says , that like-to you-swim .
ccomp(Říká, plaveš)
ccomp(He-says, you-swim)
~~~

Such clausal complements may be finite or nonfinite. However, if the
subject of the clausal complement is controlled (that is, must be the same
as the higher subject or object, with no other possible interpretation)
the appropriate relation is [xcomp]().

~~~ sdparse
Šéf nám nařídil vykopat příkop . \n Boss us ordered to-dig ditch .
ccomp(nařídil, vykopat)
ccomp(ordered, to-dig)
~~~

~~~ sdparse
Začali jsme kopat příkop . \n Started we-have to-dig ditch .
xcomp(Začali, kopat)
xcomp(Started, to-dig)
~~~

The key difference here is that, while it is possible to interpret the first
sentence to mean that the boss will not be doing any digging, in the second
sentence it is clear that the subject of __digging__ can only be __we__. This is
what distinguishes `ccomp` and `xcomp`.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/ccomp.md" target="#">edit ccomp</a>
</div>

<div about="#compound_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#compound" />
	<a id="al-cs-dep/compound" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">compound</code>: <div property="rdfs:label">compound</div></h2>
	<div property="rdfs:comment">

`compound` is one of the relations in UD for compounding.
In Czech it is used only for compound numbers.
The rightmost numeral is the head, the other numerals are attached as its modifiers.

~~~ sdparse
Bude to stát nanejvýš 50 tisíc korun . \n Will it cost at-most 50 thousand crowns .
nummod:gov(korun, tisíc)
nummod:gov(crowns, thousand)
compound(tisíc, 50-5)
compound(thousand, 50-14)
~~~

~~~ sdparse
Bude to stát padesát pět tisíc korun . \n Will it cost fifty five thousand crowns .
nummod:gov(korun, tisíc)
nummod:gov(crowns, thousand)
compound(tisíc, padesát)
compound(thousand, fifty)
compound(tisíc, pět)
compound(thousand, five)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/compound.md" target="#">edit compound</a>
</div>

<div about="#conj_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#conj" />
	<a id="al-cs-dep/conj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">conj</code>: <div property="rdfs:label">conjunct</div></h2>
	<div property="rdfs:comment">

A conjunct is the relation between two elements connected by a
coordinating conjunction, such as _and, or,_ or a comma or other punctuation.
We treat coordination asymmetrically in what is known as the Stanford style:
The head of the relation is the first
conjunct and all the other conjuncts depend on it via the `conj` relation.

~~~ sdparse
Je to starý a moudrý muž . \n Is he old and wise man .
conj(starý, moudrý)
conj(old, wise)
~~~

~~~ sdparse
Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
dobj(Máme, jablka)
dobj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(jablka, a)
cc(apples, and)
punct(jablka, ,-3)
punct(jablka, ,-5)
punct(apples, ,-13)
punct(apples, ,-15)
~~~

Coordinate clauses are treated the same way as coordination of other constituent types:

~~~ sdparse
Přišel domů , osprchoval se a hned šel do postele . \n He-came home , showered himself and immediately went to bed .
conj(Přišel, osprchoval)
conj(Přišel, šel)
conj(He-came, showered)
conj(He-came, went)
punct(Přišel, ,-3)
punct(He-came, ,-15)
cc(Přišel, a)
cc(He-came, and)
~~~

See [universal/conj](u-dep/conj) for more details on various coordination-related issues.
Note that the present conversion procedure loses some annotations of shared modifiers and nested
coordination.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/conj.md" target="#">edit conj</a>
</div>

<div about="#cop_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#cop" />
	<a id="al-cs-dep/cop" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">cop</code>: <div property="rdfs:label">copula</div></h2>
	<div property="rdfs:comment">

A copula is the relation between the nominal predicate _(přísudek jmenný)_ and
the copular verb _<b>být</b>_ “to be” (or its variants _bývat, bývávat_).
The verb _stát se_ “to become”, despite being counted among copular verbs by some authors,
is not analyzed as `cop`.

We normally take a copula as a dependent of its complement (the nominal predicate).
The nominal predicate is usually a [noun](cs-pos/NOUN), an [adjective](cs-pos/ADJ)
or a <a href="../feat/VerbForm.html#part-participle">participle</a>.

~~~ sdparse
Ondřej je čestný muž . \n Ondřej is honest man .
cop(muž, je)
cop(man, is)
~~~

~~~ sdparse
Ondřej je čestný . \n Ondřej is honest .
cop(čestný, je)
cop(honest, is)
~~~

Note that the passive participle may be also used as nominal predicate with copula.
Hence it may be difficult to distinguish a passive construction from a copula construction.
The former focuses on the process while the latter emphasizes the result.

- Passive: _Smlouva <b>byla</b>.`AUX` podepsána v&nbsp;Bílém domě._ &nbsp; “The contract was signed in the White House.”
- Copula: _Smlouva <b>byla</b>.`VERB` podepsána červeným inkoustem._ &nbsp; “The contract was signed in red ink.”

~~~ sdparse
Smlouva byla podepsána v Bílém domě . \n Contract was signed in White House .
auxpass(podepsána, byla)
auxpass(signed, was)
~~~

~~~ sdparse
Smlouva byla podepsána červeným inkoustem . \n Contract was signed in-red ink .
cop(podepsána, byla)
cop(signed, was)
~~~

The nominal predicate may also be expressed using a prepositional phrase.
However, not every occurrence of _být_ “to be” with a prepositional phrase is a copula with a nominal predicate.
Phrases expressing the state of the subject are predicates, e.g. _Lenka je v kondici_ “Lenka is in shape”.
In contrast, prepositional phrases specifying location are not predicates.
The verb _být_ is understood as the existential “to be” in such cases, and thus it itself is the predicate, not just a copula.

Thus the following two sentences receive parallel analyses:

- _Lenka je skvělá._ “Lenka is brilliant.”
- _Lenka je v kondici._ “Lenka is in shape.”

The following two will be parallel, too:

- _Lenka je v kuchyni._ “Lenka is in the kitchen.”
- _Lenka zůstala v kuchyni._ “Lenka stayed in the kitchen.”

~~~ sdparse
Lenka je v kondici . \n Lenka is in shape .
cop(kondici, je)
cop(shape, is)
case(kondici, v)
case(shape, in)
nsubj(kondici, Lenka-1)
nsubj(shape, Lenka-7)
~~~

~~~ sdparse
Lenka je v kuchyni . \n Lenka is in kitchen .
nsubj(je, Lenka-1)
nsubj(is, Lenka-7)
nmod(je, kuchyni)
nmod(is, kitchen)
case(kuchyni, v)
case(kitchen, in)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/cop.md" target="#">edit cop</a>
</div>

<div about="#csubj_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#csubj" />
	<a id="al-cs-dep/csubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubj</code>: <div property="rdfs:label">clausal subject</div></h2>
	<div property="rdfs:comment">

A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. The dependent is the main lexical verb or other 
predicate of the subject clause.

~~~ sdparse
Obžalovanému přitížilo , že neměl alibi . \n To-indictee did-a-disservice , that he-did-not-have alibi .
csubj(přitížilo, neměl)
csubj(did-a-disservice, he-did-not-have)
~~~

~~~ sdparse
Podstatou těchto vazeb je , že se děj rozloží na dvě složky . \n The-essence of-these constructions is , that one the-action splits to two parts .
csubj(Podstatou, rozloží)
cop(Podstatou, je)
csubj(The-essence, splits)
cop(The-essence, is)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/csubj.md" target="#">edit csubj</a>
</div>

<div about="#csubjpass_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#csubjpass" />
	<a id="al-cs-dep/csubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">csubjpass</code>: <div property="rdfs:label">clausal passive subject</div></h2>
	<div property="rdfs:comment">

A clausal passive subject is a clausal syntactic subject of a passive clause.

~~~ sdparse
Bylo mi doporučeno , abych to velmi dobře zvážil . \n It-has-been to-me recommended , that-I it very well weigh .
csubjpass(doporučeno, zvážil)
csubjpass(recommended, weigh)
~~~

Reflexive passive (the meaning is “You are not expected to come before nine o'clock.”)

~~~ sdparse
Nepředpokládá se , že přijdete před devátou . \n It-does-not-expect itself , that you-will-come before nine .
csubjpass(Nepředpokládá, přijdete)
csubjpass(It-does-not-expect, you-will-come)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/csubjpass.md" target="#">edit csubjpass</a>
</div>

<div about="#dep_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#dep" />
	<a id="al-cs-dep/dep" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dep</code>: <div property="rdfs:label">unspecified dependency</div></h2>
	<div property="rdfs:comment">

A dependency is labeled as `dep` when a system is unable to
determine a more precise dependency relation between two words.  This
may be because of a weird grammatical construction, a limitation in
software, a parser error, or
because of an unresolved long distance dependency.

Most `dep` instances in the current conversion of the PDT 3.0 data
correspond to the PDT label `ExD`, which marks ellipsis.
The current conversion software cannot produce the annotation conforming
to the UD standard and using the [remnant]() relation.

~~~ sdparse
K čemu ovšem , to nebylo jasné . \n For what however , that was-not clear .
dep(jasné, čemu)
dep(clear, what)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/dep.md" target="#">edit dep</a>
</div>

<div about="#det_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#det" />
	<a id="al-cs-dep/det" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">det</code>: <div property="rdfs:label">determiner</div></h2>
	<div property="rdfs:comment">

The relation determiner (`det`) holds between a nominal head and its
[determiner](cs-pos/DET).
This relation is used for pronominal adjectival modifiers of noun phrases; the `det` modifier has the POS tag [cs-pos/DET]() and vice versa.
Non-pronominal adjectives are tagged [cs-pos/ADJ]() and the relation is labeled [amod]().

Pronominal quantifiers are tagged `DET` but their relation to their head is a subtype of the `det` relation:
either [cs-dep/det:numgov]() or [cs-dep/det:nummod]().

~~~ sdparse
Ten člověk už je tady . \n The man already is here .
det(člověk, Ten)
det(man, The)
~~~

~~~ sdparse
Která kniha se vám líbí nejvíc ? \n Which book is to-you nice the-most ?
det(kniha, Která)
det(book, Which)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/det.md" target="#">edit det</a>
</div>

<div about="#det%3Anumgov_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#det" />
	<a id="al-cs-dep/det:numgov" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">det:numgov</code>: <div property="rdfs:label">pronominal quantifier governing the case of the noun</div></h2>
	<div property="rdfs:comment">

Pronominal quantifiers are labeled `det:numgov` instead of [det]()
because they normally do not agree with the quantified noun in case
(unlike non-quantifying determiners).

The quantifier requires the counted noun to be in its genitive form.
The whole phrase (quantifier + noun) is treated as a singular neuter noun phrase
and it can fill roles where nominative, accusative or vocative noun phrases are expected.

Such situations are analyzed in PDT so that the quantifier (numeral) is the head and the noun depends on it.
In UD the dependency direction is reversed and the `det:numgov` label is used to preserve
the information about case conditions.

~~~ conllu
# This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Kolik   kolik   NUM     _   Case=Nom                           3   Sb     _   How-many
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   ?       ?       PUNCT   _   _                                  0   AuxK   _   ?
~~~

~~~ sdparse
Kolik mužů hrálo karty ? \n How-many men played cards ?
det:numgov(mužů, Kolik)
nsubj(hrálo, mužů)
dobj(hrálo, karty)
punct(hrálo, ?-5)
det:numgov(men, How-many)
nsubj(played, men)
dobj(played, cards)
punct(played, ?-11)
~~~

See [nummod]() for a broader discussion of the various situations with quantifiers.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/det-numgov.md" target="#">edit det:numgov</a>
</div>

<div about="#det%3Anummod_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#det" />
	<a id="al-cs-dep/det:nummod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">det:nummod</code>: <div property="rdfs:label">pronominal quantifier agreeing in case with the noun</div></h2>
	<div property="rdfs:comment">

Pronominal quantifiers are labeled `det:nummod` or [det:numgov]() instead of [det]()
because they normally do not agree with the quantified noun in case
(unlike non-quantifying determiners).
They do agree only if the whole phrase (quantifier + noun) fills a role where
genitive, dative, locative or instrumental noun phrases are expected.
In these situations they are labeled `det:nummod`.

~~~ sdparse
Nepamatuji si , s kolika muži jsem hrál karty . \n I-do-not-remember myself , with how-many men I-have played cards .
ccomp(Nepamatuji, hrál)
compound:reflex(Nepamatuji, si)
punct(hrál, ,-3)
aux(hrál, jsem)
dobj(hrál, karty)
iobj(hrál, muži)
case(muži, s)
det:nummod(muži, kolika)
punct(Nepamatuji, .-10)
ccomp(I-do-not-remember, played)
compound:reflex(I-do-not-remember, myself)
punct(played, ,-14)
aux(played, I-have)
dobj(played, cards)
iobj(played, men)
case(men, with)
det:nummod(men, how-many)
punct(I-do-not-remember, .-21)
~~~

See [nummod]() for a broader discussion of the various situations with quantifiers.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/det-nummod.md" target="#">edit det:nummod</a>
</div>

<div about="#discourse_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#discourse" />
	<a id="al-cs-dep/discourse" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">discourse</code>: <div property="rdfs:label">discourse element</div></h2>
	<div property="rdfs:comment">

At present we use the `discourse` relation for what is labeled `AuxO` in the Prague Dependency Treebank:
redundant or emotional items, redundant coreferential pronoun.

~~~ sdparse
čemu že se to zpronevěřily \n what that themselves it they-betrayed
discourse(zpronevěřily, to)
discourse(they-betrayed, it)
~~~
(meaning “… what they betrayed”)


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/discourse.md" target="#">edit discourse</a>
</div>

<div about="#dobj_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#dobj" />
	<a id="al-cs-dep/dobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">dobj</code>: <div property="rdfs:label">direct object</div></h2>
	<div property="rdfs:comment">

The direct object of a verb is the noun phrase that denotes the entity acted upon.
Most often the direct object is in the [accusative case](cs-feat/Case) but
there are verbs that require their objects be in other cases (except for
nominative and vocative).

Accusative example:

~~~ sdparse
Koupil jsem auto . \n Bought I-have car .
dobj(Koupil, auto)
dobj(Bought, car)
~~~

Genitive example:

~~~ sdparse
Cením si vaší pomoci . \n I-appreciate REFLEX your help .
dobj(Cením, pomoci)
dobj(I-appreciate, help)
~~~

Dative example:

~~~ sdparse
Čelíme velkým problémům . \n We-face big problems .
dobj(Čelíme, problémům)
dobj(We-face, problems)
~~~

Instrumental example:

~~~ sdparse
Univerzita nedisponuje takovým rozpočtem . \n University does-not-have-at-disposal such budget .
dobj(nedisponuje, rozpočtem)
dobj(does-not-have-at-disposal, budget)
~~~

In general, if there is just one object, it should be labeled `dobj`,
regardless of the morphological case or semantic role that it bears. If there are two or more
objects, one of them should be `dobj` and the others should be
[iobj](). In such cases it is necessary to decide what is the most
directly affected object _(patient)._ The one exception is when there is a clausal complement. Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj.

## Diffs

### Prague Dependency Treebank

The manual annotation of the PDT does not distinguish direct and indirect objects.
Therefore all non-clausal dependents labeled `Obj` in PDT are currently labeled `dobj`
in the converted data, even if it results in two or more direct objects attached to one verb.
In future, the valency lexicon <a href="http://ufal.mff.cuni.cz/vallex">Vallex</a>
could be used to identify the main object.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/dobj.md" target="#">edit dobj</a>
</div>

<div about="#expl_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#expl" />
	<a id="al-cs-dep/expl" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">expl</code>: <div property="rdfs:label">expletive: reflexive pronoun with an inherently reflexive verb</div></h2>
	<div property="rdfs:comment">

Reflexive pronouns (see the feature [cs-feat/Reflex]()) usually replace objects of verbs.
However, some verbs are inherently reflexive, i.e. the verb always occurs with a reflexive
prounoun, and the pronoun cannot be replaced by a non-reflexive pronoun.

With these verbs, the reflexive pronoun is attached as `expl` instead of [dobj]().
(Note that the `expl` relation is first used for this purpose in the UD release 1.2,
to increase parallelism with other languages. In the previous releases this usage of
reflexive _se/si_ was labeled `compound:reflex`.)

~~~ sdparse
Martin se bojí zvířat . \n Martin REFLEX fears animals .
expl(bojí, se)
expl(fears, REFLEX)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/expl.md" target="#">edit expl</a>
</div>

<div about="#foreign_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#foreign" />
	<a id="al-cs-dep/foreign" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">foreign</code>: <div property="rdfs:label">foreign words</div></h2>
	<div property="rdfs:comment">

We use `foreign` to label sequences of foreign words. These are given
a linear analysis: the head is the first token in the foreign phrase.

`foreign` does not apply to loanwords or to foreign [names](name). 
It applies to quoted foreign text incorporated in a sentence/discourse
of the host language (unless we want to and know how to annotate the
internal structure according to the syntax of the foreign language).

~~~ sdparse
Jarmusch se objevil ve Wangově snímku Modrá ve tváři ( Blue in the Face ) .
foreign(Blue, in)
foreign(Blue, the)
foreign(Blue, Face)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/foreign.md" target="#">edit foreign</a>
</div>

<div about="#goeswith_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#goeswith" />
	<a id="al-cs-dep/goeswith" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">goeswith</code>: <div property="rdfs:label">goes with</div></h2>
	<div property="rdfs:comment">

This relation links two parts of a word that are separated in text
that is not well edited.
The head is in some sense the “main” part, often the second part.

~~~ sdparse
Zastavil a z těžka oddychoval .
goeswith(těžka, z)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/goeswith.md" target="#">edit goeswith</a>
</div>

<div about="#iobj_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#iobj" />
	<a id="al-cs-dep/iobj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">iobj</code>: <div property="rdfs:label">indirect object</div></h2>
	<div property="rdfs:comment">

The indirect object of a verb is any nominal phrase that is a core
argument of the verb but is not its subject or [direct object](dobj).
The prototypical example is the recipient of ditransitive verbs of
exchange:

~~~ sdparse
Pavel dal Petrovi dvě hrušky . \n Pavel gave Petr two pears .
iobj(dal, Petrovi)
iobj(gave, Petr)
~~~

However, Czech allows other semantic roles as additional objects.
The morphological [cs-feat/Case]() of the objects is dictated by verb valency.

In the following Czech example, the verb takes two arguments, both are nouns in the accusative case. One of them is direct object (patient), the other is indirect (addressee). It is parallel to how the English translation would be annotated (where there is no morphological case marking) and also to verbs of giving (consider a similar sentence, _he gave my daughter a class of maths_).

~~~ sdparse
On učí mou dceru matematiku . \n He teaches my daughter.Acc maths.Acc .
dobj(učí, matematiku)
iobj(učí, dceru)
dobj(teaches, maths.Acc)
iobj(teaches, daughter.Acc)
~~~

In general, if there is just one object, it should be labeled
[dobj](), regardless of the morphological case or semantic role.
For example, _učit_ “to teach” can take either the subject matter or the recipient as the only object,
and in both cases it would be analyzed as the [dobj]():

~~~ sdparse
Učí úvod do logiky . \n He-teaches introduction to logic .
dobj(Učí, úvod)
dobj(He-teaches, introduction)
~~~

~~~ sdparse
Učí studenty prvního ročníku . \n He-teaches students of-first year .
dobj(Učí, studenty)
dobj(He-teaches, students)
~~~

The one exception is when there is a clausal complement.
Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj, parallel to
the simple ditransitive case:

~~~ sdparse
Řekla studentům , že dnes večer musí studovat . \n She-told students , that today evening they-needed to-study .
iobj(Řekla, studentům)
ccomp(Řekla, musí)
iobj(She-told, students)
ccomp(She-told, they-needed)
~~~

~~~ sdparse
Řekla studentům svůj plán . \n She-told students her plan .
iobj(Řekla, studentům)
dobj(Řekla, plán)
iobj(She-told, students)
dobj(She-told, plan)
~~~

If there are two or
more objects, one of them should be [dobj]() and the others should be
`iobj`. In such cases it is necessary to decide what is the
most directly affected object _(patient)._

## Diffs

### Prague Dependency Treebank

The manual annotation of the PDT does not distinguish direct and indirect objects.
Therefore all non-clausal dependents labeled `Obj` in PDT are currently labeled `dobj`
in the converted data, even if it results in two or more direct objects attached to one verb.
In future, the valency lexicon <a href="http://ufal.mff.cuni.cz/vallex">Vallex</a>
could be used to identify the main object.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/iobj.md" target="#">edit iobj</a>
</div>

<div about="#list_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#list" />
	<a id="al-cs-dep/list" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">list</code>: <div property="rdfs:label">list</div></h2>
	<div property="rdfs:comment">

The `list` relation is used for chains of comparable items.
In lists with more than two items, all items of the list should modify the first one.
Informal and web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences.
Email signatures often contain these structures, in the form of contact information:
the different contact information items are labeled as `list`; the key-value pair relations are labeled as [appos]().

However, `list` should not be over-used. If a construction can be easily analyzed
using the grammatical relations of standard sentences, such as when there is overt coordination,
then it should be analyzed with these more standard relations, even if it is laid out as a list typographically.

~~~ sdparse
Steve Jones tel.: 555-9814 e-mail: jones@abc.edf
name(Steve-1, Jones-2)
list(Steve-1, tel.:-3)
list(Steve-1, e-mail:-5)
appos(tel.:-3, 555-9814-4)
appos(e-mail:-5, jones@abc.edf-6)
~~~

## Diffs

### Prague Dependency Treebank

The `list` relation is not used in the current conversion of the PDT data to UD.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/list.md" target="#">edit list</a>
</div>

<div about="#mark_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#mark" />
	<a id="al-cs-dep/mark" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mark</code>: <div property="rdfs:label">marker</div></h2>
	<div property="rdfs:comment">

A marker is the subordinating conjunction introducing a finite clause subordinate to another clause.
The mark is a dependent of the subordinate clause head.

~~~ sdparse
Nevěděl jsem , že umíš německy . \n Not-know I-did , that you-can-speak German .
mark(umíš, že)
mark(you-can-speak, that)
~~~

~~~ sdparse
Zboží odešleme , jakmile peníze dorazí na náš účet . \n Goods we-will-dispatch , as-soon-as money arrive at our account .
mark(dorazí, jakmile)
mark(arrive, as-soon-as)
~~~

Note that the subordinating conjunction should not be confused with relative pronouns and adverbs.
These fill a valency slot in the frame of the subordinate predicate,
and are labeled according to their role in the frame, they are not `mark`:

~~~ sdparse
Rád bych věděl , kdy peníze dorazí na náš účet . \n Like-to I-would know , when money arrive at our account .
advmod(dorazí, kdy)
advmod(arrive, when)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/mark.md" target="#">edit mark</a>
</div>

<div about="#mwe_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#mwe" />
	<a id="al-cs-dep/mwe" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">mwe</code>: <div property="rdfs:label">multi-word expression</div></h2>
	<div property="rdfs:comment">

The multi-word expression (modifier) relation is one of the
relations for compounding and it is intended for function words.
In Czech it is used for multi-word prepositions.
The leftmost word is the head and all the other words are attached as its `mwe` modifiers.

~~~ sdparse
Na rozdíl od tebe já se nemám zač stydět . \n In contrast to you I myself have-not of-what to-be-ashamed .
mwe(Na, rozdíl)
mwe(Na, od)
case(tebe, Na)
mwe(In, contrast)
mwe(In, to)
case(you, In)
~~~

Multi-word prepositions usually form a contiguous span of the sentence. In exceptional cases however, they can be interrupted
by emphasizers and other words:

~~~ sdparse
ve srovnání například s úvěry \n in comparison for-example to loans
mwe(ve, srovnání)
mwe(ve, s)
case(úvěry, ve)
advmod:emph(úvěry, například)
mwe(in, comparison)
mwe(in, to)
case(loans, in)
advmod:emph(loans, for-example)
~~~

Another type of interruption is caused by a possessive determiner. For instance, _na základě něčeho_ “based on something”
contains the multi-word preposition _na základě_ “based on”, lit. _on the-basis-of_. This expression is etymologically
a combination of a proper preposition _na_ “on” and the noun _základ_ “basis”; the argument _něčeho_ “something” is in
genitive. If the phrase _na základě_ were not analyzed as a multi-word expression, we would have a normal genitive
modification between two nominals: _základ něčeho_ “basis of-something”. A genitive modifier can be substituted by
a possessive determiner, and this is possible even within the partially frozen multi-word preposition, as with the
relative possessive determiner in the following example:

~~~ sdparse
zákon , na jehož základě byl zřízen fond \n law , on whose basis was created fund
nmod(zřízen, jehož)
nmod(created, whose)
case(jehož, na)
case(whose, on)
mwe(na, základě)
mwe(on, basis)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/mwe.md" target="#">edit mwe</a>
</div>

<div about="#name_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#name" />
	<a id="al-cs-dep/name" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">name</code>: <div property="rdfs:label">personal name</div></h2>
	<div property="rdfs:comment">

`name` is one of the relations for compounding in UD.
In Czech it is used to join the first (or middle) and the last name of a person.

The leftmost name is always the head and the other name(s) are attached to it.
In most cases this is the opposite to PDT where family names are heads and given names are dependents,
and the family name is usually the last name.

The relation is not used to attach adjectives to nouns within multi-word names of places, organizations etc.
(e.g. _Český Krumlov_).

~~~ sdparse
Prezident Václav Havel včera navštívil Český Krumlov . \n President Václav Havel yesterday visited Český Krumlov .
name(Václav-2, Havel-3)
name(Václav-11, Havel-12)
nmod(Václav-2, Prezident)
nmod(Václav-11, President)
amod(Krumlov-7, Český-6)
amod(Krumlov-16, Český-15)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/name.md" target="#">edit name</a>
</div>

<div about="#neg_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#neg" />
	<a id="al-cs-dep/neg" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">neg</code>: <div property="rdfs:label">negation modifier</div></h2>
	<div property="rdfs:comment">

The negation modifier is the relation between the negation word _ne_ and the
word it modifies.

Negation in Czech is most of the time expressed using a bound morpheme (the prefix _ne-_).
Occurrences of the morpheme as a separate word are rare in comparison to other languages,
yet they exist.

~~~ sdparse
Potřeboval čtyřnohého a ne dvounohého přítele . \n He-needed quadrupedal and not bipedal friend .
neg(dvounohého, ne)
neg(bipedal, not)
~~~

Note that the negative determiners (pronouns) are attached as [det](), not `neg`:

~~~ sdparse
Premiér není žádný hlupák . \n The-Prime-Minister is-not no fool .
det(hlupák, žádný)
det(fool, no)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/neg.md" target="#">edit neg</a>
</div>

<div about="#nmod_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#nmod" />
	<a id="al-cs-dep/nmod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nmod</code>: <div property="rdfs:label">nominal modifier</div></h2>
	<div property="rdfs:comment">

The `nmod` relation is used for nominal modifiers. They depend either
on another noun (group “noun dependents”) or on a predicate (group
“non-core dependents of clausal predicates”).

`nmod` is a [noun](cs-pos/NOUN) (or noun phrase) functioning as a
non-core (oblique) argument or adjunct.
This means that it functionally corresponds to an adverbial when it attaches to a verb, adjective or other adverb.
But when attaching to a noun, it usually corresponds to a non-agreeing attribute _(přívlastek neshodný)_
in genitive. (See below for an example of an agreeing attribute, _přívlastek shodný_.)

In Czech the `nmod` relation covers only those possessives that are expressed using the genitive [cs-feat/Case]().
If a possessive adjective is used, the relation is labeled [amod]().

~~~ sdparse
kancelář ředitele \n office of-the-director
nmod(kancelář, ředitele)
nmod(office, of-the-director)
~~~

~~~ sdparse
ředitelova kancelář \n director's office
amod(kancelář, ředitelova)
amod(office, director's)
~~~

~~~ sdparse
jeho kancelář \n his office
det(kancelář, jeho)
det(office, his)
~~~

`nmod` is also used for temporal nominal modifiers:

~~~ sdparse
Potkal jsem ho minulý čtvrtek . \n Met I-have him last Thursday .
nmod(Potkal, čtvrtek)
nmod(Met, Thursday)
~~~

## Agreeing attribute of a noun

`nmod` noun phrases attached to nouns are usually in the genitive [cs-feat/Case]() and follow the modified noun.
However, there is also a different kind of `nmod` that precedes the modified noun and agrees with it in case and number.
A typical example is a title attached to a name of a person. The relation is similar to the [name]() relation
that links the first and the last name, but it is not labeled `name` because the title is not part of the name:

~~~ sdparse
český prezident Václav Havel
amod(prezident, český)
nmod(Havel, prezident)
name(Havel, Václav)
~~~

Note that the same thing can be also expressed using an [apposition](appos).
In the case of apposition, the title follows the modified name and is separated by a punctuation symbol:

~~~ sdparse
Václav Havel , český prezident
name(Havel, Václav)
punct(prezident, ,-3)
amod(prezident, český)
appos(Havel, prezident)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nmod.md" target="#">edit nmod</a>
</div>

<div about="#nsubj_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubj" />
	<a id="al-cs-dep/nsubj" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubj</code>: <div property="rdfs:label">nominal subject</div></h2>
	<div property="rdfs:comment">

A nominal subject is a nominal phrase which is the syntactic subject of a clause;
in Czech, the phrase is in the nominative [cs-feat/Case]().
(See [csubj]() for when the subject is clausal.
See [nsubjpass]() and [csubjpass]() for when the subject is not the proto-agent argument due to valence changing operations.)
The governor of the `nsubj` relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun.

~~~ sdparse
Novosvětskou symfonii napsal Antonín Dvořák . \n From-the-New-World Symphony wrote Antonín Dvořák .
nsubj(napsal, Dvořák-5)
nsubj(wrote, Dvořák-12)
~~~

~~~ sdparse
Auto je červené . \n Car is red .
nsubj(červené, Auto)
nsubj(red, Car)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nsubj.md" target="#">edit nsubj</a>
</div>

<div about="#nsubjpass_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#nsubjpass" />
	<a id="al-cs-dep/nsubjpass" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nsubjpass</code>: <div property="rdfs:label">passive nominal subject</div></h2>
	<div property="rdfs:comment">

A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.

~~~ sdparse
Schwarzenberg byl poražen Zemanem . \n Schwarzenberg was defeated by-Zeman .
nsubjpass(poražen, Schwarzenberg-1)
nsubjpass(defeated, Schwarzenberg-7)
~~~

Reflexive passive (the meaning is “This will be solved tomorrow.”)

~~~ sdparse
Tohle se bude řešit zítra . \n This itself will solve tomorrow .
nsubjpass(řešit, Tohle)
nsubjpass(solve, This)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nsubjpass.md" target="#">edit nsubjpass</a>
</div>

<div about="#nummod_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#nummod" />
	<a id="al-cs-dep/nummod" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nummod</code>: <div property="rdfs:label">numeric modifier</div></h2>
	<div property="rdfs:comment">

A numeric modifier of a noun is any [number](cs-pos/NUM) phrase
that serves to modify the meaning of the noun with a quantity.

~~~ sdparse
Jan snědl tři řízky . \n Jan ate three steaks .
nummod(řízky, tři)
nummod(steaks, three)
~~~



## Agreement and government with Czech quantifiers

The morphological and syntactic behavior of Czech numerals is a complex matter.
Small cardinal numerals _jeden_ “one”, _dva_ “two”, _tři_ “three” and _čtyři_ “four” agree with the counted
noun in [cs-feat/Case]() (_jeden_ also agrees in [cs-feat/Gender]() and [cs-feat/Number]();
_dva_ also agrees in [cs-feat/Gender]()).
They behave as if they modify the counted noun; they are similar to adjectives in this respect.
Examples:

- _<b>Jeden</b> muž spal, <b>dva</b> muži hráli karty._ “One man slept, two men played cards.”
- _<b>Jedna</b> žena spala, <b>dvě</b> ženy hrály karty._ “One woman slept, two women played cards.”
- _<b>Jedno</b> kotě spalo, <b>dvě</b> koťata si hrála._ “One kitten slept, two kittens played.”

In PDT, these numerals are attached to their counted nouns as `Atr` (attribute).
It is straightforward to convert such dependencies to `nummod`:

~~~ sdparse
Jedno kotě spalo . \n One kitten slept .
nummod(kotě, Jedno)
nsubj(spalo, kotě)
punct(spalo, .-4)
nummod(kitten, One)
nsubj(slept, kitten)
punct(slept, .-9)
~~~

Larger cardinals behave differently.
They require that the counted noun be in the genitive case; this indicates that they actually govern the noun.
Such constructions are parallel to nouns modified by other noun phrases in genitive.
The whole phrase (numeral + counted noun) behaves as a noun phrase in neuter gender and singular number
(which is important for subject-verb agreement).

- _<b>Pět</b> mužů hrálo karty._ “Five men played cards.”
- _Skupina mužů hrála karty._ “A group of men played cards.”

In PDT, these numerals are analyzed as heads of the counted nouns, which are attached to the numeral as `Atr`:

~~~ conllu
# This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Pět     pět     NUM     _   Case=Nom                           3   Sb     _   Five
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   .       .       PUNCT   _   _                                  0   AuxK   _   .
~~~

There are both advantages and drawbacks to this solution.
On the one hand, it reflects well the agreement in case, gender and number.
On the other hand, it is confusing that there are two different analyses of counted noun constructions,
depending on the numeric value.

Moreover, the numeral does not govern the noun in all morphological cases.
The following table shows the case of the whole phrase (numeral + noun; first column)
and the consequences for the case of the parts (note that these numerals have only
two distinct morphological forms, resulting in homonymy).

<table>
<tr><th>Phrase Case</th><th>Example</th><th>Numeral Case</th><th>Noun Case</th></tr>
<tr><td>Nom</td><td>pět mužů</td>   <td>Nom</td><td>Gen</td></tr>
<tr><td>Gen</td><td>pěti mužů</td>  <td>Gen</td><td>Gen</td></tr>
<tr><td>Dat</td><td>pěti mužům</td> <td>Dat</td><td>Dat</td></tr>
<tr><td>Acc</td><td>pět mužů</td>   <td>Acc</td><td>Gen</td></tr>
<tr><td>Voc</td><td>pět mužů</td>   <td>Voc</td><td>Gen</td></tr>
<tr><td>Loc</td><td>pěti mužích</td><td>Loc</td><td>Loc</td></tr>
<tr><td>Ins</td><td>pěti muži</td>  <td>Ins</td><td>Ins</td></tr>
</table>

We can say that the noun has the case of the whole phrase if it is dative, locative or instrumental.
The numeral then agrees with the noun in case.
The numeral forces the noun to the genitive case if the whole phrase is nominative, accusative or vocative
(but the vocative usage is rather hypothetical).
In genitive, the noun and the numeral agree with each other; but note that the numeral uses its
inflected form, as in the other cases where it agrees with the noun.

In PDT, the genitive, dative, locative and instrumental cases are analyzed in parallel to the low-value numerals,
i.e. the noun governs the numeral:

~~~ conllu
# This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Hrál      hrát    VERB    _   Gender=Masc|Number=Sing            0   Pred   _   He-played
2   karty     karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    1   Obj    _   cards
3   s         s       ADP     _   _                                  1   AuxP   _   with
4   pěti      pět     NUM     _   Case=Ins                           6   Atr    _   five
5   dalšími   další   ADJ     _   Case=Ins|Gender=Masc|Number=Plur   6   Atr    _   other
6   muži      muž     NOUN    _   Case=Ins|Gender=Masc|Number=Plur   3   Obj    _   men
7   .         .       PUNCT   _   _                                  0   AuxK   _   .
~~~

High-value numerals where the lowest-order digit is more than zero and less than five (e.g. 21, 22, 23, 24) may behave both ways:

- _dvacet <b>dva</b> muži_ (noun governs numeral)
- _dvacet <b>dva</b> mužů_ (numeral governs noun)
- _<b>dvaadvacet</b> mužů_ (alternative form; it does not end with _dva_, thus the numeral governs the noun)
- _<b>22</b> muži_ (assuming the reader will pronounce _22_ as _dvacet dva,_ not _dvaadvacet_)
- _<b>22</b> mužů_ (pronounced either way)

Pronominal quantifiers behave as high-value numerals and govern the quantifed nouns:

- _<b>Kolik</b> mužů hrálo karty?_ “How many men played cards?”
- _<b>Několik</b> (<b>mnoho</b>, <b>málo</b>) mužů hrálo karty._ “Several (many, few) men played cards.”
- _<b>Tolik</b> mužů hrát karty jsem ještě neviděl._ “I have never seen so many men playing cards.”

~~~ conllu
# This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Kolik   kolik   NUM     _   Case=Nom                           3   Sb     _   How-many
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   ?       ?       PUNCT   _   _                                  0   AuxK   _   ?
~~~

The UD conversion of the PDT data unifies analyses of counted noun phrases
and uses a structure that is parallel among all the above cases,
and also with universal dependencies in other languages.
The counted noun is always the head and the numeral is always attached as its modifier.
Nevertheless, we use different relation labels to mark situations where the numeral (or quantifier)
actually governs the morphological case of the noun.
There are four labels used:

<table>
<tr><td></td><td><strong>Numeric</strong></td><td><strong>Pronominal</strong></td></tr>
<tr><td><strong>Noun governs</strong></td><td><tt>nummod</tt></td><td><tt><a href="det-nummod.html">det:nummod</a></tt></td></tr>
<tr><td><strong>Numeral governs</strong></td><td><tt><a href="nummod-gov.html">nummod:gov</a></tt></td><td><tt><a href="det-numgov.html">det:numgov</a></tt></td></tr>
</table>

~~~ sdparse
Tři muži hráli karty . \n Three men played cards .
nummod(muži, Tři)
nsubj(hráli, muži)
dobj(hráli, karty)
punct(hráli, .-5)
nummod(men, Three)
nsubj(played, men)
dobj(played, cards)
punct(played, .-11)
~~~

~~~ sdparse
Pět mužů hrálo karty . \n Five men played cards .
nummod:gov(mužů, Pět)
nsubj(hrálo, mužů)
dobj(hrálo, karty)
punct(hrálo, .-5)
nummod:gov(men, Five)
nsubj(played, men)
dobj(played, cards)
punct(played, .-11)
~~~

~~~ sdparse
Kolik mužů hrálo karty ? \n How-many men played cards ?
det:numgov(mužů, Kolik)
nsubj(hrálo, mužů)
dobj(hrálo, karty)
punct(hrálo, ?-5)
det:numgov(men, How-many)
nsubj(played, men)
dobj(played, cards)
punct(played, ?-11)
~~~

~~~ sdparse
Hrál jsem karty s pěti muži . \n Played I-have cards with five men .
aux(Hrál, jsem)
dobj(Hrál, karty)
iobj(Hrál, muži)
case(muži, s)
nummod(muži, pěti)
punct(Hrál, .-7)
aux(Played, I-have)
dobj(Played, cards)
iobj(Played, men)
case(men, with)
nummod(men, five)
punct(Played, .-15)
~~~

~~~ sdparse
Nepamatuji si , s kolika muži jsem hrál karty . \n I-do-not-remember myself , with how-many men I-have played cards .
ccomp(Nepamatuji, hrál)
compound:reflex(Nepamatuji, si)
punct(hrál, ,-3)
aux(hrál, jsem)
dobj(hrál, karty)
iobj(hrál, muži)
case(muži, s)
det:nummod(muži, kolika)
punct(Nepamatuji, .-10)
ccomp(I-do-not-remember, played)
compound:reflex(I-do-not-remember, myself)
punct(played, ,-14)
aux(played, I-have)
dobj(played, cards)
iobj(played, men)
case(men, with)
det:nummod(men, how-many)
punct(I-do-not-remember, .-21)
~~~



## Additional remarks

In PDT the words _milión_ “million”, _miliarda_ “billion” and higher are usually tagged as [nouns](cs-pos/NOUN),
not as [numerals](cs-pos/NUM).
In the typical case, the million is in genitive, it is preceded by a smaller number,
and it is not followed by smaller numerals (as it is in _million five hundred thousand_).
It is followed by the counted noun.
Thus the following examples receive parallel analyses:

~~~ sdparse
50 miliónů korun \n 50 millions of-crowns
nummod:gov(miliónů, 50-1)
nummod:gov(millions, 50-5)
nmod(miliónů, korun)
nmod(millions, of-crowns)
~~~

~~~ sdparse
50 pytlů bankovek \n 50 sacks of-bills
nummod:gov(pytlů, 50-1)
nummod:gov(sacks, 50-5)
nmod(pytlů, bankovek)
nmod(sacks, of-bills)
~~~

On the other hand the word _tisíc_ “thousand” may be a noun
(_na náměstí byly tisíce lidí_ “there were thousands of people in the square”)
or a numeral:

~~~ sdparse
nanejvýš 50 tisíc korun \n at-most 50 thousand crowns
advmod:emph(korun, nanejvýš)
nummod:gov(korun, tisíc)
compound(tisíc, 50-2)
advmod:emph(crowns, at-most)
nummod:gov(crowns, thousand)
compound(thousand, 50-7)
~~~

Note that the two numeral words in the above example are joined using the [compound]() relation.
Also note that the [intensifier](advmod:emph) _nanejvýš_ is attached to the head of the phrase _(korun)_ and not to the number.
This is in accord both with the UD guidelines
and with the original PDT annotation of agreeing numerals (e.g. _jen čtyři firmy, jen několik procent_).

Similarly there may be other nodes (such as punctuation) that are attached to the head of the phrase
and they are related to the whole phrase rather than directly to the head noun:

~~~ sdparse
( 9 dní ) \n ( 9 days )
punct(dní, (-1)
nummod:gov(dní, 9-2)
punct(dní, )-4)
punct(days, (-6)
nummod:gov(days, 9-7)
punct(days, )-9)
~~~

~~~ sdparse
5 minut včetně seřízení \n 5 minutes including adjustment
nummod:gov(minut, 5-1)
nmod(minut, seřízení)
case(seřízení, včetně)
nummod:gov(minutes, 5-6)
nmod(minutes, adjustment)
case(adjustment, including)
~~~

## Dates

<!-- mf920922_027.a.gz (3/19) -->
~~~ conllu
# This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1    Ředitel         ředitel         NOUN    _   _   2   Sb     _   The-director
2    navrhl          navrhnout       VERB    _   _   0   Pred   _   proposed
3    zrušit          zrušit          VERB    _   _   2   Obj    _   to-disband
4    profesionální   profesionální   ADJ     _   _   5   Atr    _   the-professional
5    scénu           scéna           NOUN    _   _   3   Obj    _   scene
6    k               k               ADP     _   _   3   AuxP   _   towards
7    31              31              NUM     _   _   9   Atr    _   the-31
8    .               .               PUNCT   _   _   7   AuxG   _   th
9    12              12              NUM     _   _   6   Adv    _   December
10   .               .               PUNCT   _   _   9   AuxG   _   .
~~~

~~~ sdparse
Ředitel navrhl zrušit profesionální scénu k 31 . 12 . \n Director proposed to-disband professional scene towards 31 st December .
advmod(zrušit, 12)
case(12, k)
punct(12, .-10)
nummod(12, 31-7)
punct(31-7, .-8)
advmod(to-disband, December)
case(December, towards)
punct(December, .-21)
nummod(December, 31-18)
punct(31-18, st)
~~~

Numerals expressed using digits are labeled `nummod` even if they represent ordinal numerals,
which would be labeled `amod`:

<!-- ln95045_123.a.gz (8/8) -->
~~~ conllu
# This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1    Letošní     letošní      ADJ     _   _   2   Atr    _   This-year's
2    veletrh     veletrh      NOUN    _   _   4   Sb     _   fair
3    se          se           PRON    _   _   4   AuxR   _   itself
4    uskuteční   uskutečnit   VERB    _   _   0   Pred   _   will-take-place
5    od          od           ADP     _   _   4   AuxP   _   from
6    9           9            NUM     _   _   5   ExD    _   9
7    .           .            PUNCT   _   _   6   AuxG   _   th
8    do          do           ADP     _   _   4   AuxP   _   to
9    12          12           NUM     _   _   11  Atr    _   12
10   .           .            PUNCT   _   _   9   AuxG   _   th
11   března      březen       NOUN    _   _   8   Adv    _   March
12   .           .            PUNCT   _   _   0   AuxK   _   .
~~~
~~~ sdparse
Letošní veletrh se uskuteční od 9 . do 12 . března . \n This-year's fair itself will-take-place from 9 th to 12 th March .
advmod(uskuteční, března)
case(března, do)
nummod(března, 12-9)
remnant(12-9, 9-6)
remnant(do, od)
advmod(will-take-place, March)
case(March, to)
nummod(March, 12-22)
remnant(12-22, 9-19)
remnant(to, from)
~~~

## Numbered objects

House number in address is attached as `nummod` to the name of the street:

~~~ sdparse
v budově Na poříčí 12 \n in the-building Na poříčí 12
nmod(budově, poříčí-4)
case(poříčí-4, Na-3)
nummod(poříčí-4, 12-5)
nmod(the-building, poříčí-10)
case(poříčí-10, Na-9)
nummod(poříčí-10, 12-11)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nummod.md" target="#">edit nummod</a>
</div>

<div about="#nummod%3Agov_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#nummod" />
	<a id="al-cs-dep/nummod:gov" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">nummod:gov</code>: <div property="rdfs:label">numeric modifier governing the case of the noun</div></h2>
	<div property="rdfs:comment">

`nummod:gov` differs from [nummod]()
in that the numeral requires the counted noun to be in its genitive form.
The whole phrase (numeral + noun) is treated as a singular neuter noun phrase
and it can fill roles where nominative, accusative or vocative noun phrases are expected.

Such situations are analyzed in PDT so that the numeral is the head and the noun depends on it.
In UD the dependency direction is reversed and the `nummod:gov` label is used to preserve
the information about case conditions.

~~~ conllu
# This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Pět     pět     NUM     _   Case=Nom                           3   Sb     _   Five
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   .       .       PUNCT   _   _                                  0   AuxK   _   .
~~~

~~~ sdparse
Pět mužů hrálo karty . \n Five men played cards .
nummod:gov(mužů, Pět)
nsubj(hrálo, mužů)
dobj(hrálo, karty)
punct(hrálo, .-5)
nummod:gov(men, Five)
nsubj(played, men)
dobj(played, cards)
punct(played, .-11)
~~~

See [nummod]() for a broader discussion of the various situations with quantifiers.


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nummod-gov.md" target="#">edit nummod:gov</a>
</div>

<div about="#parataxis_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#parataxis" />
	<a id="al-cs-dep/parataxis" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">parataxis</code>: <div property="rdfs:label">parataxis</div></h2>
	<div property="rdfs:comment">

The parataxis relation (from Greek for “place side by side”) is a
relation between a word (often the main predicate of a sentence) and other
elements, such as a sentential parenthetical or a clause after a “:” or
a “;”, placed side by side without any explicit
coordination, subordination, or argument relation with the head word. Parataxis is a discourse-like equivalent of coordination, and so usually obeys an iconic ordering. Hence it is normal for the first part of a sentence to be the head and the second part to be the parataxis dependent, regardless of the headedness properties of the language.  But things do get more complicated, such as cases of parentheticals, which appear medially.

## An inventory of constructions to which parataxis has been applied

### Treatment of reported speech

For this reported speech example:

~~~ sdparse
Ten člověk , řekl Honza , odjel brzy ráno . \n The guy , said Honza , left early in-the-morning .
parataxis(odjel, řekl)
parataxis(left, said)
~~~

there are paraphrases that convey essentially the same meaning but
with a different syntactic structure. When the reported speech is embedded in a subordinate clause (with or 
without an overt complementizer _že_ “that”), the subordinate clause is a [ccomp]() of the speech verb. When the
reported speech follows the speech verb and is separated by a colon, the reported speech forms a main clause
that attaches to the preceding main clause with a [parataxis]() relation, hence with the speech verb as its head.
However, when the speech verb occurs as a medial or final parenthetical, the relation is reversed and the speech
verb is treated as a [parataxis]() of the reported speech. 
This analysis is not uncontroversial but follows many authorities, such as Huddleston and Pullum (2002),
_The Cambridge Grammar of the English Language_ (see chapter 11, section 9). 

~~~ sdparse
Honza řekl , že ten člověk odjel brzy ráno . \n Honza said , that the guy left early in-the-morning .
ccomp(řekl, odjel)
ccomp(said, left)
~~~

~~~ sdparse
Honza řekl : „ Ten člověk odjel brzy ráno . “ \n Honza said : “ The guy left early in-the-morning . ”
parataxis(řekl, odjel)
parataxis(said, left)
~~~

~~~ sdparse
„ Ten člověk odjel brzy ráno , “ řekl Honza . \n “ The guy left early in-the-morning , ” said Honza .
parataxis(odjel, řekl)
parataxis(left, said)
~~~

~~~ sdparse
„ Ten člověk , “ řekl Honza , „ odjel brzy ráno . “ \n “ The guy , ” said Honza , “ left early in-the-morning . ”
parataxis(odjel, řekl)
parataxis(left, said)
~~~

An argument for this analysis is that in the cases analyzed as embedding, the entire clause
can be further embedded (_I was taken aback when John said the guy left early in the morning._),
while this is not possible with medial or final placement of the speech verb 
(_*I was taken aback when the guy left early this morning, John said._).

### News article bylines

The `parataxis` relation should be used to connect the parts of a news article byline.
There does not seem to be a better relation to use.

~~~ sdparse
Washington ( CNN ) :
parataxis(Washington, CNN)
~~~

### Interjected clauses and phrases

~~~ sdparse
V posledních letech se srovnávání rozšiřuje , přinejmenším pokud jde o platy , na sousední státy . \n In recent years is comparison extended , at-least as concerns about salaries , to neighboring countries .
parataxis(rozšiřuje, jde)
parataxis(extended, concerns)
~~~

## Diffs

### Prague Dependency Treebank

At present the PDT data converted to UD use `parataxis` only for interjected parentheticals.
The other examples above are analyzed differently (legacy PDT structure).


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/parataxis.md" target="#">edit parataxis</a>
</div>

<div about="#punct_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#punct" />
	<a id="al-cs-dep/punct" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">punct</code>: <div property="rdfs:label">punctuation</div></h2>
	<div property="rdfs:comment">

This is used for any piece of punctuation in a clause.
See 

~~~ sdparse
Jdi domů ! \n Go home !
punct(Jdi, !-3)
punct(Go, !-7)
~~~

Tokens with the relation `punct` always attach to content words (except in cases of ellipsis) and can never have dependents.
Since `punct` is not a normal dependency relation, the usual criteria for determining the head word do not apply. 
Instead, we use the following principles:

1. A punctuation mark separating coordinated units is attached to the first conjunct.
2. A punctuation mark preceding or following a subordinated unit is attached to this unit.
3. Within the relevant unit, a punctuation mark is attached at the highest possible node that preserves projectivity.
4. Paired punctuation marks (quotes and brackets) should be attached to the same word unless that would create non-projectivity. This word is usually the head of the phrase enclosed in the paired punctuation.

~~~ sdparse
Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
dobj(Máme, jablka)
dobj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(jablka, a)
cc(apples, and)
punct(jablka, ,-3)
punct(jablka, ,-5)
punct(apples, ,-13)
punct(apples, ,-15)
~~~

~~~ sdparse
Muž , kterého jste včera viděl , přišel zas . \n Man , whom you-have yesterday seen , came again .
punct(viděl, ,-2)
punct(seen, ,-13)
punct(viděl, ,-7)
punct(seen, ,-18)
punct(přišel, .-10)
punct(came, .-21)
~~~

~~~ sdparse
Zkratka např . znamená „ například “ . \n The-abbreviation eg . means “ for-example ” .
punct(např, .-3)
punct(eg, .-12)
punct(například, „-5)
punct(for-example, “-14)
punct(například, “-7)
punct(for-example, ”-16)
punct(znamená, .-8)
punct(means, .-17)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/punct.md" target="#">edit punct</a>
</div>

<div about="#remnant_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#remnant" />
	<a id="al-cs-dep/remnant" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">remnant</code>: <div property="rdfs:label">remnant in ellipsis</div></h2>
	<div property="rdfs:comment">

The `remnant` relation is used to provide a satisfactory treatment of certain instances of
[ellipsis](http://universaldependencies.org/cs/overview/specific-syntax.html#ellipsis)
(in the case of gapping and stripping, where a predicational or verbal
head gets elided).

~~~ sdparse
Pavel si objednal hovězí a Markéta vepřové . \n Pavel himself ordered beef and Markéta pork .
nsubj(objednal, Pavel-1)
nsubj(ordered, Pavel-10)
dobj(objednal, hovězí)
dobj(ordered, beef)
remnant(Pavel-1, Markéta-6)
remnant(Pavel-10, Markéta-15)
remnant(hovězí, vepřové)
remnant(beef, pork)
~~~

## Diffs

### Prague Dependency Treebank

At present the conversion of the PDT data to UD does not handle ellipsis properly
and the `remnant` relation is not used.

In the analytical layer of PDT, ellipsis
(together with some other issues, such as the [vocative]()) is signalled by the
dependency relation `ExD` (ex-dependent).
All the `ExD` relations that are not vocatives or comparatives are currently just re-labeled [dep]()
or [root]().


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/remnant.md" target="#">edit remnant</a>
</div>

<div about="#reparandum_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#reparandum" />
	<a id="al-cs-dep/reparandum" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">reparandum</code>: <div property="rdfs:label">overridden disfluency</div></h2>
	<div property="rdfs:comment">

We use `reparandum` to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair.

~~~ sdparse
Jděte dopra- doleva . \n Go to-the-righ- to-the-left .
reparandum(doleva, dopra-)
reparandum(to-the-left, to-the-righ-)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/reparandum.md" target="#">edit reparandum</a>
</div>

<div about="#root_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#root" />
	<a id="al-cs-dep/root" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">root</code>: <div property="rdfs:label">root</div></h2>
	<div property="rdfs:comment">

The `root` grammatical relation points to the root of the sentence. A
fake node `ROOT` is used as the governor. The `ROOT` node is indexed
with 0, since the indexing of real words in the sentence starts at 1.

~~~ sdparse
ROOT Miluju indická jídla . \n ROOT I-love Indian food .
root(ROOT-1, Miluju)
root(ROOT-7, I-love)
~~~

Since release 1.2 of the Czech UD treebank,
there is just one node with the `root` dependency relation in every
tree. If the main predicate is not present (due to
[ellipsis](http://universaldependencies.org/cs/overview/specific-syntax.html#ellipsis))
and there are
multiple orphaned dependents, the leftmost dependent is promoted to
the head (root) position and the other orphans are attached to it.

An example sentence-like segment that lacks the main verb:
_A co na to [říká] MF?_
“And what [does] MF [say] to it?”

~~~ sdparse
ROOT A co na to MF ? \n ROOT And what to it MF ?
root(ROOT-1, A)
root(ROOT-9, And)
dobj(A, co)
dobj(And, what)
nmod(A, to-5)
nmod(And, it)
case(to-5, na)
case(it, to-12)
nsubj(A, MF-6)
nsubj(And, MF-14)
punct(A, ?-7)
punct(And, ?-15)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/root.md" target="#">edit root</a>
</div>

<div about="#vocative_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#vocative" />
	<a id="al-cs-dep/vocative" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">vocative</code>: <div property="rdfs:label">vocative</div></h2>
	<div property="rdfs:comment">

The `vocative` relation is used to mark dialogue participant addressed in text.
The relation links the addressee's name to its host sentence.
In Czech, the addressee's name must also appear in the vocative [cs-feat/Case]() form.

~~~ sdparse
Pane , jste blázen ! \n Sir , you-are a-fool !
vocative(jste, Pane)
vocative(you-are, Sir)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/vocative.md" target="#">edit vocative</a>
</div>

<div about="#xcomp_cs" property="rdf:type" resource="#dep_cs">
	<div property="rdf:type" resource="../../u/dep/all.html#xcomp" />
	<a id="al-cs-dep/xcomp" class="al-dest" />

	<h2><code property="oliasystem:hasTag" lang="">xcomp</code>: <div property="rdfs:label">open clausal complement</div></h2>
	<div property="rdfs:comment">

An open clausal complement (`xcomp`) of a verb or an adjective is a
predicative or clausal complement without its own subject. The
reference of the subject is necessarily determined by an argument
external to the xcomp (normally by the subject of the next higher
clause). This is often referred to as *obligatory control*. 
These complements are always non-finite, and they are
complements (arguments of the higher verb or adjective) rather than
adjuncts/modifiers, such as a purpose clause. The name `xcomp` is
borrowed from Lexical-Functional Grammar.

~~~ sdparse
Nechceš si zaplavat ? \n Don't-you-want yourself to-swim ?
xcomp(Nechceš, zaplavat)
xcomp(Don't-you-want, to-swim)
~~~

~~~ sdparse
Začal jsem tam pracovat včera . \n Started I-have there to-work yesterday .
xcomp(Začal, pracovat)
xcomp(Started, to-work)
~~~

Note that the above condition “without its own subject” does not mean that a 
clause is an `xcomp` just because its subject is not _overt._
The subject must be necessarily inherited from a fixed position in the higher clause.
That is, there should be no available interpretation where the subject of the lower clause may be distinct
from the specified role of the upper clause.
In cases where the missing subject may or must be distinct from a fixed role in the higher clause,
[ccomp]() should be used instead, as below.  This includes cases of arbitrary subjects and anaphoric control.

~~~ sdparse
Šéf nařídil vykopat příkop . \n Boss ordered to-dig ditch .
ccomp(nařídil, vykopat)
ccomp(ordered, to-dig)
~~~

Pro-drop languages have clauses where the subject is not present as a separate word,
yet it is inherently present (and often deducible from the form of the verb)
and it does not depend on arguments from a higher clause.
Thus in neither of the following two Czech examples is there any overt subject,
yet only the second example contains an `xcomp`.

~~~ sdparse
Píšu , protože jsem to slíbil . \n I-write , because I-have it promised .
advcl(Píšu, slíbil)
advcl(I-write, promised)
~~~

~~~ sdparse
Slíbil jsem psát . \n Promised I-have to-write .
xcomp(Slíbil, psát)
xcomp(Promised, to-write)
~~~


	</div>
	<a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/xcomp.md" target="#">edit xcomp</a>
</div>


      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html
	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'cs-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
